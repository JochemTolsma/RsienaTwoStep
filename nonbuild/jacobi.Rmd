---
title: "Estimation with RsienaTwoStep"
---


#how to get sensible intitial values???
# get parallel working. best bet is to set parallel in ts_eval

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{css, echo=FALSE}
.test {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 10px;
}

.test2 {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 10px;
  background-color: white;
  color: rgb(201, 76, 76);
}


h1, .h1, h2, .h2, h3, .h3 {
  margin-top: 24px;
}





.button1 {
  background-color: grey; /* Red */ 
  border: 2px solid black;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  /* border-radius: 12px; */
  width: 100%;
}

.button1:hover {
  box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24), 0 17px 50px 0 rgba(0,0,0,0.19);
}

.button1:active {
  border: 2px solid red;
}

pre {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 0px;
}

.watch-out {
  background-color: lightpink;
  border: 3px solid red;
  font-weight: bold;
}

.large {
  max-height: 1100px;
  overflow-y: auto;
  overflow-x: auto;
  width: 1100px;
}


body{ /* Normal  */
    font-size: 14px;
}

h1 { /* Header 1 */
    font-size: 20px;
  font-weight: bold;
}

h2 { /* Header 2 */
    font-size: 18px;
  color: DarkBlue;
}

h3 { /* Header 3 */
    font-size: 16px;
  color: DarkBlue;
}

blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 14px;
  border-left: 6px solid #eee;
  background-color:lightcyan
}

caption {
  font-size: 14px;
  color: black;
  font-weight: bold
}

pre.numberSource a.sourceLine {
  left: -1em;
}

```

# 1. Getting started


```{r}
rm(list=ls())
```


## 1.1. Basic functions  


```{r}
fsave <- function(x, file, location = "./data/processed/", ...) {
    if (!dir.exists(location))
        dir.create(location)
    datename <- substr(gsub("[:-]", "", Sys.time()), 1, 8)
    totalname <- paste(location, datename, file, sep = "")
    print(paste("SAVED: ", totalname, sep = ""))
    save(x, file = totalname)
}

fpackage.check <- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

colorize <- function(x, color) {
    sprintf("<span style='color: %s;'>%s</span>", color, x)
}

```

## 1.2. Packages

```{r}
packages = c("RsienaTwoStep", "RSiena", "doParallel", "compiler", "ggplot2", "sna")

fpackage.check(packages)
```


---  

# 2. Setting up cluster

```{r}
#stopCluster(my.cluster) 
n.cores <- parallel::detectCores() - 1  #save one core for other work
# create the cluster
my.cluster <- parallel::makeCluster(n.cores, type = "PSOCK")
# register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)

parallel::clusterEvalQ(my.cluster, library("RsienaTwoStep"))
parallel::clusterEvalQ(my.cluster, library("RSiena"))
parallel::clusterEvalQ(my.cluster, library("network"))
```

---  

# 3. Estimate a basic model with RSiena

## 3.1. Model 1: Degree and reciprocity 

Make sure that in `sienaAlgorithmCreate()`: the argument `cond` is set to `FALSE` so the rate parameter is estimated and can be accessed via `summary(ans)$theta`.  
Make sure that in `siena07` the `returnDeps` argument is set to `TRUE` so the simulated networks are saved. 
If you want to be able to replicate the simulated networks by `siena07` it is best to estimate `siena07` for one period (two waves) only. 

We only include the following statistics:  
- degree  
- reciprocity  

```{r, eval=FALSE}
library(RSiena)
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata <- sienaDataCreate(mynet)
myalgorithm <- sienaAlgorithmCreate(seed=1293, cond=FALSE, findiff = TRUE) #toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
#myeff <- includeEffects(myeff, transTrip, inAct)
ans1 <- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)
```


```{r, eval=FALSE}
myalgorithm2 <- sienaAlgorithmCreate(seed=1294, cond=FALSE, findiff = TRUE) #toggle set conditional to retrieve the rate parameter in theta!
ans2 <- siena07(myalgorithm2, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)

myalgorithm <- sienaAlgorithmCreate(seed=1293, cond=FALSE, findiff = FALSE) #toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
ans1b <- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)

myalgorithm2 <- sienaAlgorithmCreate(seed=1294, cond=FALSE, findiff = FALSE) #toggle set conditional to retrieve the rate parameter in theta!
ans2b <- siena07(myalgorithm2, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)

```

rsiena:
                                     Estimate   Standard   Convergence 
                                                  Error      t-ratio   
  1. rate basic rate parameter mynet  5.9458  ( 1.0185   )   -0.0735   
  2. eval outdegree (density)        -1.7774  ( 0.1719   )    0.0779   
  3. eval reciprocity                 2.7071  ( 0.2562   )    0.1164   
  4. eval transitive triplets         0.8310  ( 0.0940   )    0.1365   
  5. eval indegree - activity        -0.4667  ( 0.0515   )    0.1093   

ts_ministep

               estim        SE
rate       4.8434944 0.7487897
degree    -1.4114484 0.4319428
recip      3.0715435 0.2416906
transTrip  0.8995729 0.1752413
inAct     -0.5370058 0.1374104

ts_estim(mydata=mydata, myeff=myeff, nite = 100, p2step = c(0,1,0))
4.560655 -1.4004632  2.94715622  0.87608364 -0.83560877

ts_estim(ans=ans1, nite = 100, p2step = c(0,1,0), dist1=2, dist2=2)

# Let us have a look at the Jacobi-matrix

For fase 1  stored in `ans1$dinvv`. 
Actually, I think they are stored in dfra1, because for fase 3 we use this matrix to replicate the SE. 

```{r, eval=FALSE}
solve(ans1$dinvv)
ans1$dfra1
solve(ans2$dinvv)
solve(ans1b$dinvv)
solve(ans2b$dinvv)
```
An important conclusion is that the Jacobi-matrix differs not only due to randomness (different seed) between ans1a/b and ans2a/b but also between method how to calculate ans1/2a vs ans1/2b. 

```{r, eval=FALSE, echo=FALSE}
fsave(ans1, file="ans1.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221220ans1.Rdata")
ans1 <- x
rm(x)
```

let's have a look
```{r}
ans1
ans1b
```


# 4. Estimation with RsienaTwoStep

The first step generally will involve estimating the model from `RSiena:siena07()`. 
The target statistics are then retrieved from the `ans` object. However, it is a good idea to check if the target statistics obtained via `RsienaTwoStep` are identical. 

## 4.1. Determine the target statistics

### 4.1.1. A manual check

#### For Model 1

```{r}
simrate <- sum(abs(s502 - s501)) # count the number of changes between the networks. 

simdegree <- foreach(i= 1:nrow(s502), .combine="c") %dopar%
  ts_degree(net=s502, ego=i) |>
  sum()

#this is the general logic. Calculate the statistic for each ego for the network at T=2 and sum for all ego's. 
simrecip <- foreach(i= 1:nrow(s502), .combine="c") %dopar%
  ts_recip(net=s502, ego=i) |>
  sum()

targets_jt <- c(simrate, simdegree, simrecip)

targets_jt
ans1$targets
```
Or we could use the build-in function of the `RsieanaTwoStep` package `ts_targets`. 

```{r}
ts_targets(ans=ans1)
```
#### For Model 2

Please note that the cycle3 target is not the sum for all egos. Instead, it is divided by 3 (thus the count of 3cycles). 
```{r}
ans2$targets
ts_targets(ans=ans2) 
```
## 4.2. Fase 1 of the algorithm

### First by use of simulation via Rsiena

It seems I have to transpose my matrix of partial derivatives. Ask Christian. Yes, apparently.
It seems that `ans$dinvv` is for fase 1 and `ans$dinv` is for fase 3!!
- to do include an important effect transtrip, this will tell us if we indeed need to transpose our matrix. 

```{r}
sim_model <- sienaAlgorithmCreate( projname = "sim_model", cond = FALSE,
useStdInits = FALSE, nsub = 0 , simOnly = TRUE, seed = 23457)

#myeff$initialValue[myeff$include]  <- ans1$theta

sim_ans <- siena07(sim_model, data = mydata, effects = myeff )
stats <- t(t(sim_ans$sf) + sim_ans$targets)

# different values can be specified by assigning the desired value to the vector
myeff1 <- myeff
myeff1$initialValue[myeff$include][1] <- myeff$initialValue[myeff$include][1] + myeff$initialValue[myeff$include][1]/10
sim_ans <- siena07(sim_model, data = mydata, effects = myeff1 )
stats1 <- t(t(sim_ans$sf) + sim_ans$targets)

# different values can be specified by assigning the desired value to the vector
myeff2 <- myeff
myeff2$initialValue[myeff$include][2] <- myeff$initialValue[myeff$include][2] + 0.1
sim_ans <- siena07(sim_model, data = mydata, effects = myeff2 )
stats2 <- t(t(sim_ans$sf) + sim_ans$targets)

# different values can be specified by assigning the desired value to the vector
myeff3 <- myeff
myeff3$initialValue[myeff$include][3] <- myeff$initialValue[myeff$include][3] + 0.1 
sim_ans <- siena07(sim_model, data = mydata, effects = myeff3 )
stats3 <- t(t(sim_ans$sf) + sim_ans$targets)

res_mat <- matrix(NA, nrow=3, ncol=3)
res_mat[1,] <- colMeans((stats1 - stats)/ (myeff$initialValue[myeff$include][1]/10)) 
res_mat[2,] <- colMeans((stats2 - stats)/0.1) #degree
res_mat[3,] <- colMeans((stats3 - stats)/0.1) #recip
```

compare the partial derivatives
```{r}
t(res_mat)
ans1$dfra1 #I am not sure why this deviates from dinvv
solve(ans1$dinvv)
# solve(ans2$dinvv)
# solve(ans1b$dinvv)
# solve(ans2b$dinvv)
```


### simulation via RsienaTwoStep

Well, in fase 1, the initial values are determined and the D matrix to scale everything during the algorithm. 

We could simply use the initial values as saved in our `ans` object, assuming that twostep-processess will not deviate too much from ministep processes. We then could also use the D matrix which is saved here. 



Let us define the statistics we are interested in. for now only rate and degree/density, reciprocity.
```{r}
statistics <- list(ts_degree, ts_recip) #rate is automatically included
names(statistics) <- c("degree", "recip")
startvalue_rate <- summary(myeff)$initialValue[1]
startvalue_param <- summary(myeff)$initialValue[-1] #suppose these are the start values of our parameters
netstart <- mydata$depvars$mynet[,,1]
```


We can simulate a future network conditional on the observed network net1 and the statistics with parameters on their start values. 


Let us determine z_bar
```{r}
Nsim <- 100 # 1000 is default in RSiena
crn <- sample(12345:4567890, Nsim) #common random numbers?
pn <- length(statistics) + 1
deviation <- ans1$epsilon #just take these from RSiena 

res <- matrix(NA, nrow=Nsim, ncol=pn)
res2 <- matrix(NA, nrow=Nsim, ncol=pn)
count <- 1

#zbar
for (i in 1:Nsim) {
  set.seed(crn[i]) #is this just our crn
  sim_net <- ts_sim(net=netstart, rate=startvalue_rate, statistics=statistics, parameters = startvalue_param, p2step=c(1,0,0))
  res[count,] <- ts_targets(net1=netstart, net2=sim_net, statistics=statistics)
  count <- count + 1
}
```

compare z-bar as simulated via RSiena and RsienaTwoStep
```{r}
colMeans(res) #RsienaTwoStep
colMeans(stats) #RSiena
```

```{r}
#rate
for (i in 1:Nsim) {
  set.seed(crn[i]) #is this just our crn
  sim_net <- ts_sim(net=netstart, rate=startvalue_rate + deviation[1], statistics=statistics, parameters = startvalue_param, p2step=c(1,0,0))
  res2[i,] <- ts_targets(net1=netstart, net2=sim_net, statistics=statistics)
  count <- count + 1
}
res <- cbind(res, res2)

#statistics
for (j in 1:length(statistics)) {
  startvalue_param2 <- startvalue_param
  startvalue_param2[j] <- startvalue_param2[j] + deviation[1+j]
  for (i in 1:Nsim) {
    set.seed(crn[i]) #is this just our crn
    sim_net <- ts_sim(net=netstart, rate=startvalue_rate, statistics=statistics, parameters = startvalue_param2, p2step=c(1,0,0))
    res2[i,] <- ts_targets(net1=netstart, net2=sim_net, statistics=statistics)
    count <- count + 1
  }
  res <- cbind(res, res2)
}
#res
```


```{r}
res_mat <- matrix(NA, nrow=pn, ncol=pn)
# res_mat[1,] <- colMeans((res[,4:6] - res[,1:3] )/deviation) #rate
# res_mat[2,] <- colMeans((res[,7:9] - res[,1:3])/deviation) #degree
# res_mat[3,] <- colMeans((res[,10:12] - res[,1:3])/deviation) #recip


res_mat[1,1] <- mean((res[,4] - res[,1])/deviation[1])
res_mat[1,2] <- mean((res[,5] - res[,2])/deviation[1])
res_mat[1,3] <- mean((res[,6] - res[,3])/deviation[1])

res_mat[2,1] <- mean((res[,7] - res[,1])/deviation[2])
res_mat[2,2] <- mean((res[,8] - res[,2])/deviation[2])
res_mat[2,3] <- mean((res[,9] - res[,3])/deviation[2])

res_mat[3,1] <- mean((res[,10] - res[,1])/deviation[3])
res_mat[3,2] <- mean((res[,11] - res[,2])/deviation[3])
res_mat[3,3] <- mean((res[,12] - res[,3])/deviation[3])
```


```{r}
colMeans(res[,1:3]) #RsienaTwoStep
colMeans(res[,4:6]) #RsienaTwoStep
colMeans(res[,7:9]) #RsienaTwoStep
colMeans(res[,10:12]) #RsienaTwoStep

colMeans(stats) #RSiena
colMeans(stats1) #RSiena
colMeans(stats2) #RSiena
colMeans(stats3) #RSiena
```
It seems the simulated Z values are okay via RsienaTwoStep

```{r}
D <- t(res_mat)
D
ans1$dfra1
solve(ans1$dinvv)
```

The Jacobi-matrix is quite a bit off. Probably because of low number of simulations. Need to check! 

```{r}
hist((res[,4] - res[,1])/deviation[1])
mean((res[,4] - res[,1])/deviation[1])

colMeans((res[,4:6] - res[,1:3] )/deviation)[1]
```



## 4.3. Fase 2 of the algorithm

### 4.3.1. Model 1

This is the actual estimation of the parameters. 
Let us first see that if we plug-in the estimated parameters as initial values we retrieve once again the estimated parameters, if we use the algorithm as programmed in `RsienaTwoStep`. 


```{r, eval=FALSE}
estim1 <- ts_estim(ans=ans1, parallel=TRUE, conv=.01) 
```

Note that the algorithm has not yet converged after 100 iterations. You could increase the number of iteration via the `nite` argument. But as you can see the statistics are already very close. 

```{r}
estim1
```

But does it also work if we start with initial values that are way of? 
```{r, eval=FALSE}
estim2 <- ts_estim(ans=ans1, startvalues = c(2,1,1), parallel=TRUE, conv=0.05)
```

```{r}
estim2
```

Yes, it seems to find the same solution. 

We could now use this to estimate the model under the different twostep assumptions. 
Please note though that this will take up quite some time. 

Let us start with strict coordination. 
```{r}
estim3 <- ts_estim(ans=ans1, parallel=TRUE, conv=0.05, p2step=c(0,1,0), dist1=2)
```

```{r}
estim3
```

```{r}
estim4 <- ts_estim(ans=ans1, parallel=TRUE, p2step=c(0,1,0), dist1=2, dist2=2)
```

Let us summarize what we have got. 

```{r}
res <- t(rbind(estim2[nrow(estim2), ], estim3[nrow(estim3), ]), estim4[nrow(estim4), ])
colnames(res) <- c("MS", "TS-strict", "TS-weak")
```

### 4.3.2. Model 2

```{r}
estim5 <- ts_estim(ans=ans2, parallel=TRUE, conv=.05)
estim6 <- ts_estim(ans=ans2, parallel=TRUE, conv=.05, p2step=c(0,1,0), dist1=2)
estim7 <- ts_estim(ans=ans2, parallel=TRUE, conv=.05, p2step=c(0,1,0), dist1=2, dist2=2)
estim8 <- ts_estim(ans=ans2, parallel=TRUE, conv=.05, p2step=c(0,0,1))
```


Let us summarize what we have got. 

```{r}
res <- t(rbind(estim5[nrow(estim5), ], estim6[nrow(estim6), ]), estim7[nrow(estim7), ], estim8[nrow(estim8), ])
colnames(res) <- c("MS", "TS-strict", "TS-weak", "SS")
```

## 4.4. Fase 3 of the algorithm

## Replicate SE as reported by RSiena via simulations with RSiena

```{r}
sim_model <- sienaAlgorithmCreate( projname = "sim_model", cond = FALSE,
useStdInits = FALSE, nsub = 0 , simOnly = TRUE, seed = 23457)

myeff$initialValue[myeff$include]  <- ans1$theta

sim_ans <- siena07(sim_model, data = mydata, effects = myeff )
stats <- t(t(sim_ans$sf) + sim_ans$targets)

# different values can be specified by assigning the desired value to the vector
myeff1 <- myeff
myeff1$initialValue[myeff$include][1] <- myeff$initialValue[myeff$include][1] + myeff$initialValue[myeff$include][1]/10
sim_ans <- siena07(sim_model, data = mydata, effects = myeff1 )
stats1 <- t(t(sim_ans$sf) + sim_ans$targets)

# different values can be specified by assigning the desired value to the vector
myeff2 <- myeff
myeff2$initialValue[myeff$include][2] <- myeff$initialValue[myeff$include][2] + myeff$initialValue[myeff$include][2]/10
sim_ans <- siena07(sim_model, data = mydata, effects = myeff2 )
stats2 <- t(t(sim_ans$sf) + sim_ans$targets)

# different values can be specified by assigning the desired value to the vector
myeff3 <- myeff
myeff3$initialValue[myeff$include][3] <- myeff$initialValue[myeff$include][3] + myeff$initialValue[myeff$include][3]/10
sim_ans <- siena07(sim_model, data = mydata, effects = myeff3 )
stats3 <- t(t(sim_ans$sf) + sim_ans$targets)

res_mat <- matrix(NA, nrow=3, ncol=3)
res_mat[1,] <- colMeans((stats1 - stats)/ (myeff$initialValue[myeff$include][1]/10)) 
res_mat[2,] <- colMeans((stats2 - stats)/ (myeff$initialValue[myeff$include][2]/10))  #degree
res_mat[3,] <- colMeans((stats3 - stats)/ (myeff$initialValue[myeff$include][3]/10))  #recip
```



```{r}
t(res_mat)
ans1$dfrac
ans1$dfra
solve(ans1$dinv)
# solve(ans1$dinvv)
# solve(ans1b$dinv)
# solve(ans1b$dinvv)
```

```{r}
cov(ans1$sf)
cov(stats)
```


```{r}
ans1$covtheta
sqrt(diag(ans1$covtheta))
ans1
# solve(ans1$dfrac) %*% cov(ans1$sf) %*% t(solve(ans1$dfrac)) #same as above but show we know where the parts are in the ans1 object
```


```{r}
D <- t(res_mat)
solve(D) %*% cov(stats) %*% t(solve(D))
```

## via RsienaTwoStep

Let us define the statistics we are interested in. for now only rate and degree/density, reciprocity.

```{r}
statistics <- list(ts_degree, ts_recip) #rate is automatically included
names(statistics) <- c("degree", "recip")
startvalue_rate <- ans1$theta[1]
startvalue_param <- ans1$theta[-1] #suppose these are the start values of our parameters
netstart <- mydata$depvars$mynet[,,1]
```


We can simulate a future network conditional on the observed network net1 and the statistics with parameters on their start values. 


Let us determine z_bar
```{r}
Nsim <- 100 # 1000 is default in RSiena
crn <- sample(12345:4567890, Nsim) #common random numbers?
pn <- length(statistics) + 1
deviation <- ans1$epsilon #just take these from RSiena 

res <- matrix(NA, nrow=Nsim, ncol=pn)
res2 <- matrix(NA, nrow=Nsim, ncol=pn)
count <- 1

#zbar
for (i in 1:Nsim) {
  set.seed(crn[i]) #is this just our crn
  sim_net <- ts_sim(net=netstart, rate=startvalue_rate, statistics=statistics, parameters = startvalue_param, p2step=c(1,0,0))
  res[count,] <- ts_targets(net1=netstart, net2=sim_net, statistics=statistics)
  count <- count + 1
}

#rate
for (i in 1:Nsim) {
  set.seed(crn[i]) #is this just our crn
  sim_net <- ts_sim(net=netstart, rate=startvalue_rate + deviation[1], statistics=statistics, parameters = startvalue_param, p2step=c(1,0,0))
  res2[i,] <- ts_targets(net1=netstart, net2=sim_net, statistics=statistics)
  count <- count + 1
}
res <- cbind(res, res2)

#statistics
for (j in 1:length(statistics)) {
  startvalue_param2 <- startvalue_param
  startvalue_param2[j] <- startvalue_param2[j] + deviation[1+j]
  for (i in 1:Nsim) {
    set.seed(crn[i]) #is this just our crn
    sim_net <- ts_sim(net=netstart, rate=startvalue_rate, statistics=statistics, parameters = startvalue_param2, p2step=c(1,0,0))
    res2[i,] <- ts_targets(net1=netstart, net2=sim_net, statistics=statistics)
    count <- count + 1
  }
  res <- cbind(res, res2)
}
#res
```


```{r}
res_mat <- matrix(NA, nrow=pn, ncol=pn)
# res_mat[1,] <- colMeans((res[,4:6] - res[,1:3] )/deviation) #rate
# res_mat[2,] <- colMeans((res[,7:9] - res[,1:3])/deviation) #degree
# res_mat[3,] <- colMeans((res[,10:12] - res[,1:3])/deviation) #recip


res_mat[1,1] <- mean((res[,4] - res[,1])/deviation[1])
res_mat[1,2] <- mean((res[,5] - res[,2])/deviation[1])
res_mat[1,3] <- mean((res[,6] - res[,3])/deviation[1])

res_mat[2,1] <- mean((res[,7] - res[,1])/deviation[2])
res_mat[2,2] <- mean((res[,8] - res[,2])/deviation[2])
res_mat[2,3] <- mean((res[,9] - res[,3])/deviation[2])

res_mat[3,1] <- mean((res[,10] - res[,1])/deviation[3])
res_mat[3,2] <- mean((res[,11] - res[,2])/deviation[3])
res_mat[3,3] <- mean((res[,12] - res[,3])/deviation[3])
```

```{r}
ans1$covtheta
sqrt(diag(ans1$covtheta))
D <- t(res_mat)
solve(D) %*% cov(res[,1:3]) %*% t(solve(D))

sqrt(diag(solve(D) %*% cov(res[,1:3]) %*% t(solve(D))))
```

--- 





This is the most complicated part. We reestimate the model with the estimated parameters (and small deviation thereof) and determine the observed statistics Z. 

```{r}
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata <- sienaDataCreate(mynet)
myalgorithm <- sienaAlgorithmCreate(seed=1293, cond=FALSE) #toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
myeff$initialValue

#calculate Z with original startvalues

start <- c(4.69604, -1.48852, 0)
crn <- sample(10:100, 20, replace=FALSE)/100
```


```{r}
fase3 <- list()

for (i in 1:length(crn)) {
  fase3[[i]] <- f.error(ans=ans1, startvalues=start, fase2=FALSE)
}
ori <- fase3
Zm <- colMeans(do.call(rbind, ori))

#now let us add deviations for degree to the startvalues. 


#calculate the new Z with these values
fase3 <- list()
for (i in 1:length(crn)) {
  start2 <- start
  start2[1] <- start2[1] + crn[i]
  fase3[[i]] <- f.error(ans=ans1, startvalues=start2, fase2=FALSE)
}
rate <- fase3

#take difference with Z from previous step
dif <-  mapply(function(x,y) x-y, rate, ori)
dif / crn

#for the degree statistic, divide by the small change and take average
d11 <- mean(dif[1,] / crn)
d12 <- mean(dif[2,] / crn)
d13 <- mean(dif[3,] / crn)



fase3 <- list()
for (i in 1:length(crn)) {
  start2 <- start
  start2[2] <- start2[2] + crn[i]
  fase3[[i]] <- f.error(ans=ans1, startvalues=start2, fase2=FALSE)
}
degree <- fase3

#take difference with Z from previous step
dif <-  mapply(function(x,y) x-y, degree, ori)
dif / crn

#for the degree statistic, devide by the small change and take average
d21 <- mean(dif[1,] / crn)
d22 <- mean(dif[2,] / crn)
d23 <- mean(dif[3,] / crn)

#calculate the new Z with these values
fase3 <- list()
for (i in 1:length(crn)) {
  start2 <- start
  start2[3] <- start2[3] + crn[i]
  fase3[[i]] <- f.error(ans=ans1, startvalues=start2, fase2=FALSE)
}

recip <- fase3

#take difference with Z from previous step
dif <-  mapply(function(x,y) x-y, recip, ori)
dif / crn

#for the degree statistic, devide by the small change and take average
d31 <- mean(dif[1,] / crn)
d32 <- mean(dif[2,] / crn)
d33 <- mean(dif[3,] / crn)

d_jt <- matrix(c(d11,d12,d13,d21,d22,d23,d31,d32,d33), nrow=3, byrow=TRUE)
solve(d_jt)

```


# error function

```{r}
f.error <- function(startvalues=NULL, targets=NULL, net=NULL, statistics=NULL, p2step=c(1,0,0), ans=NULL){
  
  if (is.null(startvalues)) startvalues <- ans$theta
  if (is.null(targets)) targets <- ans$targets
  if (is.null(net)) net <- (ans$f$Data1$depvars$mynet)[,,1]
  if (is.null(statistics)) {
    statistics <- ans$effects$shortName
    statistics[statistics=="density"] <- "degree"
    statistics <- as.list((paste0("ts_", statistics))[-1])
    statistics <- lapply(statistics, get)
  }
  
  #estimate model
  Z <- rep(NA, length(targets))
  sims1 <- ts_sims(nsims=1, parallel=TRUE, net=net, rate=startvalues[1], statistics=statistics, parameters=startvalues[-1], p2step=p2step, chain=FALSE)
  Z[1] <- sum(abs(sims1[[1]] - net))
  
  for (j in 1:length(statistics)) {
    Z[j + 1] <- foreach(i= 1:nrow(sims1[[1]]), .combine="c") %dopar%
      statistics[[j]](net=sims1[[1]], ego=i) |>
      sum()
    }  
    
  update <- Z - targets
  update
}
```


```{r}
f.error(ans=ans1)
```


```{r}
ts_robmun <- function(startvalues=NULL, targets=NULL, net=NULL, statistics=NULL, p2step=c(1,0,0), ans=NULL, b=0.5, verbose=TRUE, nite=100) {
  
  if (is.null(startvalues)) startvalues <- ans$theta

  x = startvalues 
  dif = Inf
  ite = 0
  ite2 = 1 #try to keep an constant as long as the sequence sn has not crossed the observed values
  r = x
  r_sub = x #for the subphase
  update = 0
  
  while (dif > .0001 & ite < nite){
    ite = ite + 1 #number of iterations
    a = (1/ite2)^b
    update_old = update
    update = f.error(startvalues=x, targets=targets, net=net, statistics=statistics, p2step=p2step, ans=ans)
    x = x - diag(ans$dinv)*a*update #if ans is not provided divide bij nnodes?
    r = rbind(r,x) # save results
    r_sub = rbind(r_sub,x) # save results
    if (sum(abs(sign(update) - sign(update_old)) == 2)>1 )  {
      ite2 = ite2 + 1 
      x <- colMeans(r_sub) #for new subphase take average of sequence as new starting value
      r_sub <- x 
    }
    if ((ite %% 3) == 0){
      dif = sum(abs(x - r[ite-2])) #TO DO: check how is implemented
    }
    if (verbose) print(x)
    if (verbose) print(paste0("ite: ", ite))
    if (verbose) print(paste0("ite2: ", ite2))
  }
  return(r)
}  

```

```{r}

res <- ts_robmun(startvalues= ans1$theta + c(-3,2,1), ans=ans1)
{plot(1:101, res[,1])
abline(h=res[1,1])}

{plot(1:101, res[,2])
  abline(h=res[1,2])}
  
```

https://stats.stackexchange.com/questions/514680/root-finding-via-robbins-monro-method-a-real-and-simple-example




# more complex model

preparing the dataset
```{r}
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
alcohol <- s50a
smoke <- s50s
smoke <- coCovar(smoke[, 1])
alcohol <- coCovar(alcohol[, 1])
mydata <- sienaDataCreate(mynet, smoke, alcohol)

myeff <- getEffects(mydata)
myeff <- includeEffects(myeff, transTrip, cycle3)
myeff <- includeEffects(myeff, egoX, altX, egoXaltX, interaction1 = "alcohol")
myeff <- includeEffects(myeff, simX, interaction1 = "smoke")
ans2 <- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)
```


#to do: rebuild package with new effects

retrieve effects in correct format for rsienatwostep
```{r}
ans <- ans2
 statistics <- ans$effects$shortName
    statistics[statistics=="density"] <- "degree"
    statistics <- as.list((paste0("ts_", statistics))[-1])
    statistics <- lapply(statistics, get)
    
    str(ans$effects,1)
    length(statistics)
    
    for (i in 1:length(statistics)) {
      if (ans$effects$interaction1[i+1]!="") {
        statistics[[i]] <- list(statistics[[i]], ans$effects$interaction1[i+1] )
      }
    }
    
    ans$effects$interaction1
```

retrieve the dataframe for rsienaincorrect format
```{r}

#mydata is also stored in ans
ans3$f$Data1$cCovars

x <- as.numeric(mydata$cCovars[[1]]) + attr(mydata$cCovars[[1]], "mean")

length(mydata$cCovars)


data <- matrix(NA, nrow=length(mydata$cCovars[[1]]), ncol=length(mydata$cCovars))
for (i in 1: length(mydata$cCovars)) {
  data[,i] <- as.numeric(mydata$cCovars[[i]]) + attr(mydata$cCovars[[i]], "mean")
}

ccovar <- as.data.frame(data)
colnames(ccovar) <- names(mydata$cCovars)

```


```{r, eval=FALSE}
# Ministep
sims1 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,0,0), chain=FALSE)

# Twostep: Simultaneity 
sims2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,1,0), chain=FALSE)

# Twostep: Weak coordination 
sims3 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,1,0), dist1=2, dist2=2, chain=FALSE)

### Twostep: Strict coordination 
sims4 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,1,0), dist1=2, chain=FALSE)

### Simstep 
sims5 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,0,1), chain=FALSE)
```



```{r, echo=FALSE, eval=FALSE}
fsave(sims1, file="sims1.Rdata")
fsave(sims2, file="sims2.Rdata")
fsave(sims3, file="sims3.Rdata")
fsave(sims4, file="sims4.Rdata")
fsave(sims5, file="sims5.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221220sims1.Rdata")
sims1 <- x
rm(x)

load("./data/processed/20221220sims2.Rdata")
sims2 <- x
rm(x)

load("./data/processed/20221221sims3.Rdata")
sims3 <- x
rm(x)

load("./data/processed/20221221sims4.Rdata")
sims4 <- x
rm(x)

load("./data/processed/20230114sims5.Rdata")
sims5 <- x
rm(x)
```

## 3.3. Counting dyads

### 3.3.1. RSiena

```{r}
gofi <- sienaGOF(ans1,
                 DyadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 varName = "mynet")
```

```{r}
dfrs <- as.data.frame(gofi[[1]]$Simulations)
names(dfrs) <- c("Mut", "Asym", "Null")

df <- rbind(dfrs, dfrs, dfrs)
df$x <- rep(c("mut", "asym", "null"), each=nrow(dfrs))
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "rsiena"
dfrs_siena <- df
rm(list=c("df", "dfrs"))
```


### 3.3.2. RsienaTwoStep 


```{r}
df_ts1 <- ts_dyads(sims=sims1, simtype="ministep") 
df_ts2 <- ts_dyads(sims=sims2, simtype="twostep-simultaneity")
df_ts3 <- ts_dyads(sims=sims3, simtype="twostep-weak coordination") 
df_ts4 <- ts_dyads(sims=sims4, simtype="twostep-strict coordination")
df_ts5 <- ts_dyads(sims=sims5, simtype="simstep")
```

## 3.4. Plotting dyad_census 

### 3.4.1. All three dyad types  

```{r}
df <- rbind(dfrs_siena, df_ts1, df_ts2, df_ts3, df_ts4, df_ts5)



p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

### 3.4.2. Plotting dyad census selection 

```{r}


df_sel <- df[df$x!="null", ]

dodge <- position_dodge(width = 0.5)
p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

---  

# 4. Model 2: Degree, reciprocity and 3cycle 

## 4.1. Running `siena07()`  

We only include the following statistics:  
- degree  
- reciprocity  
- cycle3  


```{r, eval=FALSE}
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata <- sienaDataCreate(mynet)
myalgorithm <- sienaAlgorithmCreate(seed=1293, cond=FALSE) #toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
myeff <- includeEffects(myeff, cycle3)
ans2 <- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)
```


```{r, eval=FALSE}
fsave(ans2, file="ans2.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221222ans2.Rdata")
ans2 <- x
rm(x)
```

let's have a look
```{r}
ans2
```


## 4.2. Simulate networks via `RsienaTwoStep`  

`r colorize("These simulations took two days to complete on a simple HP Elitebook 855 G7", "red" )`

```{r, eval=FALSE, class.source="watch-out"}
#ministep
sims1m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(1,0,0), chain=FALSE)
fsave(sims1m2, file="sims1m2.Rdata")

#simultaneity
sims2m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,1,0), chain=FALSE)
fsave(sims2m2, file="sims2m2.Rdata")

#weak coordination
sims3m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,1,0), dist1=2, dist2=2, chain=FALSE)
fsave(sims3m2, file="sims3m2.Rdata")

#strict coordination
sims4m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,1,0), dist1=2, chain=FALSE)
fsave(sims4m2, file="sims4m2.Rdata")

#simstep
sims5m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,0,1), chain=FALSE)
fsave(sims5m2, file="sims5m2.Rdata")

```


```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221222sims1m2.Rdata")
sims1m2 <- x
load("./data/processed/20221223sims2m2.Rdata")
sims2m2 <- x
load("./data/processed/20221223sims3m2.Rdata")
sims3m2 <- x
load("./data/processed/20221224sims4m2.Rdata")
sims4m2 <- x
load("./data/processed/20230114sims5m2.Rdata")
sims5m2 <- x
rm(x)
```

## 4.3. Counting dyads

### 4.3.1. RSiena

```{r}
gofi <- sienaGOF(ans2,
                 DyadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 varName = "mynet")
```

```{r}
dfrs <- as.data.frame(gofi[[1]]$Simulations)
names(dfrs) <- c("Mut", "Asym", "Null")

df <- rbind(dfrs, dfrs, dfrs)
df$x <- rep(c("mut", "asym", "null"), each=nrow(dfrs))
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "rsiena"
dfrs_sienam2 <- df
rm(list=c("df", "dfrs"))
```

### 4.3.2. RsienaTwoStep 

```{r}
df_ts1m2 <- ts_dyads(sims=sims1m2, simtype="ministep") 
df_ts2m2 <- ts_dyads(sims=sims2m2, simtype="twostep-simultaneity")
df_ts3m2 <- ts_dyads(sims=sims3m2, simtype="twostep-weak coordination") 
df_ts4m2 <- ts_dyads(sims=sims4m2, simtype="twostep-strict coordination")
df_ts5m2 <- ts_dyads(sims=sims5m2, simtype="simstep")
```

## 4.4. Plotting dyad_census

### 4.4.1. All three dyad types  

```{r}
df <- rbind(dfrs_sienam2, df_ts1m2, df_ts2m2, df_ts3m2, df_ts4m2, df_ts5m2)

p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

### 4.4.2. Plotting dyad census selection 
```{r}
df_sel <- df[df$x!="null", ]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```


## 4.5. Counting triads

### 4.5.1. RSiena
```{r}
nsims <- 1000
gofi <- sienaGOF(ans2,
                 TriadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 varName = "mynet")

dfrs <- as.data.frame(gofi[[1]]$Simulations)

triads <- c("003",  "012",  "102" , "021D", "021U", "021C" ,"111D", "111U" ,"030T" ,"030C", "201"  ,"120D" ,"120U" ,"120C" ,"210",  "300")

names(dfrs) <- triads


dflist <- list()
for (i in 1:length(triads)) {
  dflist[[i]] <- dfrs
}
dfrs <- do.call(rbind, dflist)
dfrs$x <- rep(triads, each=nsims)
dfrs$y <- NA

for (i in 1:length(triads)) {
  dfrs$y[dfrs$x==triads[i]] <- dfrs[,triads[i]][dfrs$x==triads[i]]
}
dfrs$type <- "rsiena"
dfrs_sienam2 <- dfrs
```


### 4.5.2 RsienaTwoStep

```{r}
df_ts1m2 <- ts_triads(sims=sims1m2, simtype="ministep") 
df_ts2m2 <- ts_triads(sims=sims2m2, simtype="twostep-simultaneity")
df_ts3m2 <- ts_triads(sims=sims3m2, simtype="twostep-weak coordination") 
df_ts4m2 <- ts_triads(sims=sims4m2, simtype="twostep-strict coordination")
df_ts5m2 <- ts_triads(sims=sims5m2, simtype="simstep")
```


## 4.6. Plotting triad census 

### 4.6.1. All triad types  

```{r}
df <- rbind(dfrs_sienam2, df_ts1m2, df_ts2m2, df_ts3m2, df_ts4m2, df_ts5m2)

p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(1)) +
  labs(x = "triad type", y = "triad count", fill="simulation type")

p
```

### 4.6.2 Plotting triad census selection I

```{r}
df_sel <- df[df$x=="030C" | df$x=="120C",]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "(cyclic) triad types", y = "triad count", fill="simulation type")

p
```

### 4.6.3 Plotting triad census selection II

```{r}
df_sel <- df[df$x=="210" | df$x=="300",]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "(cyclic) triad types", y = "triad count", fill="simulation type")

p
```

---  

# 5. Conclusion 

- The networks simulated by `RsienaTwoStep` assuming the ministep assumption lead to identical results as the simulated networks of `RSiena`. We can hence conclude that (at least for the used statistics) `RsienaTwoStep` is programmed correctly.  
- For both model specifications, we observe that allowing for simultaneity does not really impact the observed dyads and triads in the network, although reciprocated ties seem a bit more likely. This is reassuring. A tentative conclusion would be that for relatively sparse and large networks it 'does not matter' to disregard simultaneous tie changes.  
- Both forms of coordination (weak and strict) lead to more reciprocated ties.  
- The dyad and triad census of the networks simulated assuming 'weak coordination' deviate the most from the other simulated networks. The assumption made under weak coordination is that also actors who are **`r colorize("not", "red")` connected at time t0** can initiate a coordinated tie-change. Hence, it is called weak coordination. However, these actors only evaluate twostep tie changes that lead to a connection at time t2. In other words, their choice set is reduced.  
- Under strict coordination, it is assumed that only actors **connected at time t0** can start a coordination. Hence, it is called strict coordination. These actors evaluate all twostep tie changes (also those that would be the result of two independent ministeps). In our ABM we specified that there was only strict coordination (parameter `p2step=c(0,1,0`). This will probably mean that some actors made a lot more tie-changes than others. It may be worthwhile to mix twosteps with ministeps and simsteps (i.e., `p2step=c(0.33,0.33,0.34)`).  
- Under the simstep assumption, we observe more asymmetric dyads. This, intuitively makes sense, because you cannot make a reciprocated tie all by yourself. More surprisingly is that also cyclic triads (030C and 120C) seem to occur relatively often. Whether or not this is solely the results of the abundance of asymetric dyads remains to be investigated. 



---  

```{r}
#let us define the statistics we are interested in. for now only rate and degree/density. 

statistics <- list(ts_degree) #rate is automatically included
names(statistics) <- c("degree")
startvalue <- c(2,-1) #suppose these are the start values of our parameters
```


```{r}
#we can simulate a future network conditional on the observed network net1 and the statistics with parameters on their start values. 

sim_net <- ts_sim(net=net1, rate=startvalue[1], statistics=statistics, parameters = startvalue[2], p2step=c(1,0,0))
sim_net
```


```{r}
#of this simulated network we can calculate the target values corresponding to the statistics. That is the elements of vector Z, the z_k.  
ts_targets(net1=net1, net2=sim_net, statistics=statistics)
```


```{r}
#but naturally, if I would repeat this I will get slightly different values. 
sim_net <- ts_sim(net=net1, rate=startvalue[1], statistics=statistics, parameters = startvalue[2], p2step=c(1,0,0))
ts_targets(net1=net1, net2=sim_net, statistics=statistics)
```
Thus use N = 100 and determine z_bar
```{r}
res <- matrix(NA, nrow=100, ncol=2)
for (i in 1:100) {
  sim_net <- ts_sim(net=net1, rate=startvalue[1], statistics=statistics, parameters = startvalue[2], p2step=c(1,0,0))
  res[i,] <- ts_targets(net1=net1, net2=sim_net, statistics=statistics)
}
colMeans(res)
```
But now I can tweak the start values a bit. 
But the text on pag 391 of Snijders 2002 I do not understand, so probably I tweak the parameters wrong. 

first for degree
```{r}
res2 <- matrix(NA, nrow=100, ncol=2)
for (i in 1:100) {
  sim_net <- ts_sim(net=net1, rate=startvalue[1], statistics=statistics, parameters = startvalue[2] + 0.5, p2step=c(1,0,0))
  res2[i,] <- ts_targets(net1=net1, net2=sim_net, statistics=statistics)
}
colMeans(res2)

```
then for rate

```{r}
res3 <- matrix(NA, nrow=100, ncol=2)
for (i in 1:100) {
  sim_net <- ts_sim(net=net1, rate=startvalue[1] + 0.5, statistics=statistics, parameters = startvalue[2], p2step=c(1,0,0))
  res3[i,] <- ts_targets(net1=net1, net2=sim_net, statistics=statistics)
}
colMeans(res3)
```
Is this not already enough to determine the partiel derivatives? 
```{r}
drate <- mean((res3[,1] - res[,1])/0.5)
ddegree <- mean((res2[,2] - res[,2])/0.5)
```
# now use a real ans object

```{r}
ts_targets(ans=ans1)
```
```{r}
#let us define the statistics we are interested in. for now only rate and degree/density, reciprocity. 

statistics <- list(ts_degree, ts_recip) #rate is automatically included
names(statistics) <- c("degree", "recip")
startvalue_rate <- summary(myeff)$initialValue[1]
startvalue_param <- summary(myeff)$initialValue[-1] #suppose these are the start values of our parameters

netstart <- mydata$depvars$mynet[,,1]
```

```{r}
#we can simulate a future network conditional on the observed network net1 and the statistics with parameters on their start values. 

sim_net <- ts_sim(net=netstart, rate=startvalue_rate, statistics=statistics, parameters = startvalue_param, p2step=c(1,0,0))
sim_net
```

```{r}
ts_targets(net1=netstart, net2=sim_net, statistics=statistics)
```
Thus use N = 100 and determine z_bar
```{r}
res <- matrix(NA, nrow=10, ncol=3)
for (i in 1:10) {
  sim_net <- ts_sim(net=netstart, rate=startvalue_rate, statistics=statistics, parameters = startvalue_param, p2step=c(1,0,0))
  res[i,] <- ts_targets(net1=netstart, net2=sim_net, statistics=statistics)
}

```
