% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/estim.R
\name{ts_estim}
\alias{ts_estim}
\alias{ts_targets}
\alias{ts_phase1}
\alias{ts_phase3}
\title{Estimation of parameters via Robbins-Monro algorithm}
\usage{
ts_estim(
  ans = NULL,
  mydata = NULL,
  myeff = NULL,
  startvalues = NULL,
  net1 = NULL,
  net2 = NULL,
  ccovar = NULL,
  statistics = NULL,
  b = 0.5,
  conv = 0.001,
  nite = 1000,
  itef1 = 50,
  itef3 = 1000,
  p2step = c(1, 0, 0),
  dist1 = NULL,
  dist2 = NULL,
  modet1 = "degree",
  modet2 = "degree",
  verbose = TRUE,
  parallel = FALSE,
  returnDeps = FALSE,
  phase1 = TRUE,
  phase3 = TRUE
)

ts_targets(
  ans = NULL,
  mydata = NULL,
  myeff = NULL,
  net1 = NULL,
  net2 = NULL,
  ccovar = NULL,
  statistics = NULL
)

ts_phase1(
  ans = NULL,
  mydata = NULL,
  myeff = NULL,
  net1 = NULL,
  net2 = NULL,
  ccovar = NULL,
  statistics = NULL,
  itef1 = 100,
  p2step = c(1, 0, 0),
  dist1 = NULL,
  dist2 = NULL,
  modet1 = NULL,
  modet2 = NULL,
  verbose = TRUE,
  parallel = FALSE
)

ts_phase3(
  ans = NULL,
  mydata = NULL,
  myeff = NULL,
  net1 = NULL,
  net2 = NULL,
  ccovar = NULL,
  statistics = NULL,
  startvalues = NULL,
  itef3 = 100,
  p2step = c(1, 0, 0),
  dist1 = NULL,
  dist2 = NULL,
  modet1 = NULL,
  modet2 = NULL,
  verbose = TRUE,
  parallel = FALSE,
  returnDeps = FALSE
)
}
\arguments{
\item{ans}{Results of class sienaFit, produced by a call to
\code{\link[RSiena:siena07]{RSiena::siena07()}}}

\item{mydata}{Siena data object created by a call to
\code{\link[RSiena:sienaDataCreate]{RSiena::sienaDataCreate()}}}

\item{myeff}{Siena effects object created by a call to
\code{\link[RSiena:getEffects]{RSiena::getEffects()}}}

\item{startvalues}{if not provided manually, taken from results of
\code{ans$theta}, or if \code{ans} is not provided from
\code{summary(myeff)$initialValue}.}

\item{net1}{adjacency matrix, the adjacency matrix representing the relations
between actors at Time=1. Valid values are 0 and 1. If not provided
manually, retrieved from \code{ans} or \code{mydata}.}

\item{net2}{adjacency matrix, the adjacency matrix representing the relations
between actors at Time=2. Valid values are 0 and 1. If not provided
manually, retrieved from \code{ans} or \code{mydata}.}

\item{ccovar}{data frame with named time-constant covariates. If not provided
manually, retrieved from \code{ans} or \code{mydata}.}

\item{statistics}{list of statistics of \code{RsienaTwoStep}, see: \code{\link[=ts_degree]{ts_degree()}}
and DETAILS. If not provided manually, retrieved from \code{ans} or \code{myeff}.}

\item{b}{numeric between 0.1 and 1 (default =0.5), used in Robbins-Monro
algorithm.}

\item{conv}{numeric. Robbins-Monro algorithm stops if the mean deviation of
parameters after each update steps become smaller than \code{conv}}

\item{nite}{number of iterations phase2 (actual estimation of parameters)}

\item{itef1}{number of total iterations phase1 (To get to a crude Jacobian
matrix, which can be used in phase2) )}

\item{itef3}{number of total iterations phase3 (To estimate SE). This phase
will take the longest.}

\item{p2step}{numeric vector of length 3, setting the ratio of ministep,
twostep and twoministeps. This parameter is passed to \code{\link[=ts_sims]{ts_sims()}}.}

\item{dist1}{numeric, minimal path length between ego1 and ego2 at time1 in
order to be allowed to start a cooperation. If \code{NULL} all dyads are allowed
to start a cooperation. This parameter is passed to \code{\link[=ts_sims]{ts_sims()}}.}

\item{dist2}{numeric, minimal path length between ego1 and ego2 at time2 in
order for twostep to be counted as cooperation. This parameter is passed to
\code{\link[=ts_sims]{ts_sims()}}.}

\item{modet1}{string, indicating the type of ties being evaluated at time1.
"\emph{degree}" considers all ties as undirected. "\emph{outdegree}" only allows
directed paths starting from ego1 and ending at ego2. "\emph{indegree}" only
allows directed paths starting from ego2 and ending at ego2. This parameter
is passed to \code{\link[=ts_sims]{ts_sims()}}.}

\item{modet2}{string, indicating the type of ties being evaluated at time2.
"\emph{degree}" considers all ties as undirected. "\emph{outdegree}" only allows
directed paths starting from ego1 and ending at ego2. "\emph{indegree}" only
allows directed paths starting from ego2 and ending at ego2. This parameter
is passed to \code{\link[=ts_sims]{ts_sims()}}.}

\item{verbose, }{TRUE/FALSE. If set to true it shows the iteration steps and
some results.}

\item{parallel}{Boolean. TRUE/FALSE.}

\item{returnDeps}{Boolean. If \code{TRUE} the simulated dependent variables
(networks, behaviour) of phase3 will be returned.}

\item{phase1}{TRUE/FALSE, If False no Jacobian matrix is calculated.}

\item{phase3}{TRUE/FALSE, if FALSE no SE are calculated}
}
\value{
A dataframe of estimated parameters. The last row are the final
solutions of the Robbins Monro algorithm.
}
\description{
\code{ts_estim} is the workhorse function of the package
\code{RsienaTwoStep}. For details on the simulation function see \code{\link[=ts_sims]{ts_sims()}}.
This function aims to estimate the model parameters according to the
Robbins-Monro algorithm as described in
\insertCite{snijders2001statistical}{RsienaTwoStep}.
}
\details{
For examples on how to use \code{ts_estim()} see:
\code{vignette("1.Introduction_RsienaTwoStep", package="RsienaTwoStep")} or
the \href{https://jochemtolsma.github.io/RsienaTwoStep/}{package website}.
Before you set \code{parallel} to TRUE make sure to set-up a cluster with the
package \code{doParallel} (see \code{Examples}).
\itemize{
\item \code{p2step==c(1,0,0)}: ministep
\item \code{p2step==c(0,1,0)} & dist1==NULL & dist2==NULL: twostep-simultaneity
\item \code{p2step==c(0,1,0)} & dist1!=NULL & dist2==NULL: twostep-strict coordination
\item \code{p2step==c(0,1,0)} & dist1!=NULL & dist2!=NULL: twostep-weak coordination
\item \code{p2step==c(0,0,1)}: two-ministeps
}
}
\examples{
\dontrun{
# It is good practice to check if `RsienaTwoStep` uses the same
# target values as `RSiena`, which can be retrieved like: `ans$targets`.
ts_targets(net1 = s501, net2 = s502, statistics = list(ts_degree, ts_recip))
# In normal use case you do not want to estimate the Jacobian matrix yourself
# for phase 1. We simply use the matrix from `RSiena`. Except if you really
# expect different outcomes from the twostep model and not using a
# Dinv matrix at all does not work.
# Phase 1 only
jac <- ts_phase1(net1 = s501,
 net2 = s502,
 statistics = list(ts_degree, ts_recip),
 ccovar = NULL,
 itef1 = 30)
dinv <- solve(jac)
#estimate without the use of RSiena
ts_estim(net1 = s501,
net2 = s502,
statistics = list(ts_degree, ts_recip),
nite = 30,
 phase1 = FALSE)
 #estimate without the use of RSiena
ts_estim(net1 = s501,
net2 = s502,
statistics = list(ts_degree, ts_recip),
nite = 30,
itef1 = 10,
phase1 = TRUE)
#estimate without the use of RSiena
ts_estim(net1 = s501,
 net2 = s502,
 statistics = list(ts_degree, ts_recip),
 nite = 30,
 itef1 = 10,
 phase1 = TRUE,
 itef3 = 10,
 phase3 = TRUE)
# Phase 3 only
startvalues <- c(5.5, -2.2, 2.4)
stat <- list(ts_degree, ts_recip)
ts_phase3(startvalues = startvalues,
net1 = s501,
statistics = stat,
itef3 = 10,
verbose = TRUE)
library(RSiena)
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata <- sienaDataCreate(mynet)
myalgorithm <- sienaAlgorithmCreate(cond=FALSE)
#toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
ts_estim(mydata = mydata, myeff = myeff)
#warning, this may take a while!
ts_estim(mydata = mydata, myeff = myeff, phase3 = TRUE)
ans1 <- siena07(myalgorithm, data=mydata, effects=myeff)
ts_estim(ans1)
}

}
\references{
\insertRef{ripley2022manual}{RsienaTwoStep}
\insertRef{snijders2001statistical}{RsienaTwoStep}
}
\seealso{
\code{\link[=ts_sims]{ts_sims()}},
\code{\link[=ts_degree]{ts_degree()}},
\code{\link[RSiena:siena07]{RSiena::siena07()}}
}
