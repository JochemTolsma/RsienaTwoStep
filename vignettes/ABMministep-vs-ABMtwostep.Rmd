---
title: "ABMministep-vs-ABMtwostep"
output: 
  html_document:
    css: tweaks.css
    highlight: haddock
    number_sections: yes
    self_contained: yes
    theme: lumen
    toc: yes
    toc_depth: 3
    toc_float: yes
    mathjax: null
    code_download: yes
    code_folding: show 
vignette: >
  %\VignetteIndexEntry{ABMministep-vs-ABMtwostep}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
# knitr::opts_chunk$set(
#   collapse = TRUE,
#   comment = "#>"
# )
# 
# knitr::opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE, warning = FALSE, cache=TRUE, message = FALSE,comment = "#>")
# options(width = 100)
# rgl::setupKnitr()


knitr::opts_chunk$set(tidy.opts=list(width.cutoff=100),tidy=TRUE, warning = FALSE, message = FALSE,comment = "#>", cache=TRUE, class.source=c("test"), class.output=c("test2"), cache.lazy = FALSE)
options(width = 100) 
rgl::setupKnitr()

colorize <- function(x, color) {sprintf("<span style='color: %s;'>%s</span>", color, x) }


```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy('')
klippy::klippy(position = c('top', 'right'))
#klippy::klippy(color = 'darkred')
#klippy::klippy(tooltip_message = 'Click to copy', tooltip_success = 'Done')
```


```{r setup}
library(RsienaTwoStep)
library(igraph)
```

```{css, echo=FALSE}
.test {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 10px;
}

.test2 {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 10px;
  background-color: white;
  color: rgb(201, 76, 76);
}


h1, .h1, h2, .h2, h3, .h3 {
  margin-top: 24px;
}





.button1 {
  background-color: grey; /* Red */ 
  border: 2px solid black;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  /* border-radius: 12px; */
  width: 100%;
}

.button1:hover {
  box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24), 0 17px 50px 0 rgba(0,0,0,0.19);
}

.button1:active {
  border: 2px solid red;
}

pre {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 0px;
}

.watch-out {
  background-color: lightpink;
  border: 3px solid red;
  font-weight: bold;
}

.large {
  max-height: 1100px;
  overflow-y: auto;
  overflow-x: auto;
  width: 1100px;
}


body{ /* Normal  */
    font-size: 14px;
}

h1 { /* Header 1 */
    font-size: 20px;
  font-weight: bold;
}

h2 { /* Header 2 */
    font-size: 18px;
  color: DarkBlue;
}

h3 { /* Header 3 */
    font-size: 16px;
  color: DarkBlue;
}

blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 14px;
  border-left: 6px solid #eee;
  background-color:lightcyan
}

caption {
  font-size: 14px;
  color: black;
  font-weight: bold
}

pre.numberSource a.sourceLine {
  left: -1em;
}

```

# Toy data

Let us have a look at the build-in datasets of `RsienaTwoStep`. 

## net1

### the adjacency matrix

```{r }
net1
```

### the plot

```{r, message=FALSE, warning=FALSE}
net1g <- graph_from_adjacency_matrix(net1, mode="directed")
plot(net1g)
```

## net2

### the adjacency matrix

```{r}
net2
```

### the plot

```{r, message=FALSE, warning=FALSE}
net2g <- graph_from_adjacency_matrix(net2, mode="directed")
plot(net2g)
```


Make sure `igraph` is unloaded. 

```{r}
unloadNamespace("igraph")
```

---  

# ABM ministep

Let us suppose we want to know what the possible networks are after all possible ministeps of one actor part of `net2`. That is, let us assume that it is ego#2's turn to decide on tie-change. What are the possible networks? 

## possible networks after ministep  

```{r}
options <- f_alternatives_ministep(net=net2, ego=2)
options
```

This function returns a list of all possible networks after all possible tie-changes available to ego#2 given network `net2`. If you look closely you will see that `options[[2]]` equals the original network (i.e. ego#2 decided not to change any tie). 

## network statistics 

Which option will ego#2 choose? Naturally this will depend on which network characteristics (or statistics) ego#2 finds relevant. Let us suppose that ego#2 bases its decision solely on the number of ties it sends to others and the number of reciprocated ties it has with others. 

Let us count the number of ties ego#2 sends to alters. 

```{r}
f_degree(net=options[[1]], ego=2)
```
And in the second (original) option: 

```{r}
f_degree(net=options[[2]], ego=2)
```
In the package `RsienaTwoStep` there are functions for the following network statistics (see the RSiena manual chapter 12 for the mathematical formulation):  

- degree (f_degree)  
- reciprocity (f_recip)  
- outdegree activity (f_outAct)  
- indegree activity (f_inAct)  
- outdegree popularity (f_outPop)  
- indegree popularity (f_inPop)  
- transitivity (f_transTrip)  
- mediated transitivity (f_transMedTrip)  

Naturally, you are free to define your own network statistics or make a merge request on GitHub. 

## evaluation function 

But what evaluation value does ego#2 attach to these network statistics and consequently to the network (in its vicinity) as a whole? Well these are the parameters you will normally estimate with `siena07`. 
Let us suppose the importance for the statistic 'degree' is -1 and for the statistic 'reciprocity' is 2. 

So you could calculate the evaluation of the network saved in `options[[2]]` by hand: 

```{r}
-1*1 + 2*0
```

or with a little help of the network statistic functions:  

```{r}
-1*f_degree(net=options[[2]], ego=2) + 2* f_recip(net=options[[2]], ego=2)
```
Or you could use the `f_eval()`. 

```{r}
eval <- f_eval(net=options[[2]], ego=2, statistics=list(f_degree, f_recip), parameters=c(-1,2))
eval
```
Now, let us calculate the evaluation of all 10 possible networks: 
```{r}
eval <- sapply(options, FUN=f_eval, ego=2, statistics=list(f_degree, f_recip), parameters=c(-1,2))
eval
```
So which option will ego#2 choose? Naturally this will be a stochastic process. But we see the last option has the highest evaluation. 
We use McFadden's choice function: 

Let us force ego#2 to make a decision. 

```{r}
choice <- sample(1:length(eval), size=1, prob=exp(eval)/sum(exp(eval)))
print("choice:") 
choice
print("network:")
options[[choice]]
```

If we repeat this process, that is...: 

1. sample agent  
2. construct possible alternative networks  
3. calculate how sampled agent evaluates the possible networks  
4. Let the agent pick a network, that is, let agent decide on a tie-change  
5. GO BACK TO 1 (STOPPING RULE: until you think we have made enough ministeps)

...we have an agent based model.   

But how many ministeps do we allow? Well, normally this is estimated by `siena07` by the `rate` parameter. If we do not make this rate parameter conditional on actor covariates or on network characteristics, the rate parameter can be interpreted as the average number of ministeps each actor in the network is allowed to make before time is up. Let us suppose the `rate` parameter is 2 `r rate<-2`. Thus in total the number of possible ministeps will be `nrow(net2)*rate`: `r nrow(net2)*rate`. For a more detailed - **and more correct** interpretation of the rate parameter in `siena07` see: [www.jochemtolsma.nl/courses/complete-networks/socio6]

To demonstrate:  

```{r}
f_sims(nsims=1, net=net2, rate=2, statistics=list(f_degree, f_recip), parameters = c(-1,2), chain = TRUE )
```

---  

# ABM twostep

## general logic

The general logic of the ABM that allows for twosteps is very similar to the ABM ministep model: 

1. sample **two** agents  
2. construct possible alternative networks  
3. calculate how the sampled agents evaluate the possible networks  
4. Let the agents together pick the subsequent network, that is, let agents decide on the twostep (the simultaneous two ministeps)  
5. GO BACK TO 1 (STOPPING RULE: until you think we have made enough ministeps/twosteps)

### 1. Sample two agents  

### 2. Construct alternative networks  

we simply let first agent1 make all possible ministeps and then conditional on these alternative networks let agent2 make all possible ministeps. Please note that the order in which we let agents make the ministeps is not important. We simple construct all the networks that could result from agent1 and agent2 make a simultaneous ministep.  

#### Exception  



### 3. Evaluation rule

We start by letting each involved agent evaluate all possible networks based on the individual evaluation function. 
Thus agent1 gives an evaluation and agent2 gives an evaluation.  
Next we have to decide how these separate evaluations are to be combined. We could for example take the highest evaluation. For now, in `RsienaTwoStep` we simply take the mean of the two evaluations. 

### 4. Decision rule

Here also we follow the same logic. If we know the evaluation score of each network we simply apply a Mc Fadden's choice function. That is the actors together 'decide' on the future network, given the combined evaluation of these networks.  

### 5. Stopping rule

Once again the logic is exactly similar. However, we count a twostep as two ministeps. Thus if each actor is allowed to make on average 8 minstep, actors are allowed to make on average 5 twosteps. 

---  

# Running simulations on toy data

## setting up cluster 

```{r}
library(doParallel)
#stopCluster(my.cluster) 
n.cores <- parallel::detectCores() - 1  #save one core for other work
# create the cluster
my.cluster <- parallel::makeCluster(n.cores, type = "PSOCK")
# register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)
```


## Degree and reciprocity 

Let us assume people really don't like to have a non-reciprocal tie but do like reciprocal ties a lot. (I only want to help you if you help me!)

Thus if you start with a network without many (reciprocal) ties it would be very difficult to get more reciprocal ties in the normal ministep model. However, with simultaneity this should be possible. 

### simulate networks for three conditions

```{r}
sims1 <- f_sims(nsims=1000, parallel=TRUE, net=net1, rate=10, statistics=list(f_degree, f_recip), parameters=c(-1,2), p2step=0, chain=FALSE) #ministep only

sims2 <- f_sims(nsims=1000, parallel=TRUE, net=net1, rate=10, statistics=list(f_degree, f_recip), parameters=c(-1,2), p2step=1, chain=FALSE) #twostep, random selection of dyads

sims3 <- f_sims(nsims=1000, parallel=TRUE, net=net1, rate=10, statistics=list(f_degree, f_recip), parameters=c(-1,2), p2step=1, dist1=2, dist2=2, chain=FALSE) #twostep, but not all options are seen as coordination 
```

### counting dyads

```{r}
nsims <- 1000

#combine results of dyad.census
df <- foreach(1:nsims, i=icount(), .combine="rbind") %dopar% {
  sna::dyad.census(sims3[[i]])
}
df <- as.data.frame(df)

#bit clumsy
df <- rbind(df, df, df)
df$x <- rep(c("mut", "asym", "null"), each=nsims)
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "twostep-coordination"
dftwostepNR <- df

df <- foreach(1:nsims, i=icount(), .combine="rbind") %dopar% {
  sna::dyad.census(sims2[[i]])
}
df <- as.data.frame(df)

#bit clumsy
df <- rbind(df, df, df)
df$x <- rep(c("mut", "asym", "null"), each=nsims)
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "twostep-simultaneity"
dftwostepR <- df

df <- foreach(1:nsims, i=icount(), .combine="rbind") %dopar% {
  sna::dyad.census(sims1[[i]])
}
df <- as.data.frame(df)

#bit clumsy
df <- rbind(df, df, df)
df$x <- rep(c("mut", "asym", "null"), each=nsims)
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "ministep"
dfministep <- df

## combine datasets

df <- rbind(dfministep, dftwostepR, dftwostepNR)
```

### plot results of the three dyadcensus 

```{r}
library(ggplot2)

p <- ggplot(df, aes(x=x, y=y, fill=type)) + 
  geom_violin(position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(1)) 
  
p

```

### conclusion

Yes, if you allow simultaneity, we will observe more reciprocal ties after same number of possible tie-changes. 

Perhaps the model with ministeps only would reach the same target values (for dyads) but probably by using more possible tie-changes. This would mean there will be more noise in the network chains, this can/will have results for other network statistics. 

Thus,...I think we are on to something. 

Also note, that if you make the network larger, simultaneity will less likely to be different from two consecutive ministeps, this is because the two agents do not influence each others evaluation functions. 

---  


