---
title: "RSienaWorkFlow"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{css, echo=FALSE}
.test {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 10px;
}

.test2 {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 10px;
  background-color: white;
  color: rgb(201, 76, 76);
}


h1, .h1, h2, .h2, h3, .h3 {
  margin-top: 24px;
}





.button1 {
  background-color: grey; /* Red */ 
  border: 2px solid black;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  /* border-radius: 12px; */
  width: 100%;
}

.button1:hover {
  box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24), 0 17px 50px 0 rgba(0,0,0,0.19);
}

.button1:active {
  border: 2px solid red;
}

pre {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 0px;
}

.watch-out {
  background-color: lightpink;
  border: 3px solid red;
  font-weight: bold;
}

.large {
  max-height: 1100px;
  overflow-y: auto;
  overflow-x: auto;
  width: 1100px;
}


body{ /* Normal  */
    font-size: 14px;
}

h1 { /* Header 1 */
    font-size: 20px;
  font-weight: bold;
}

h2 { /* Header 2 */
    font-size: 18px;
  color: DarkBlue;
}

h3 { /* Header 3 */
    font-size: 16px;
  color: DarkBlue;
}

blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 14px;
  border-left: 6px solid #eee;
  background-color:lightcyan
}

caption {
  font-size: 14px;
  color: black;
  font-weight: bold
}

pre.numberSource a.sourceLine {
  left: -1em;
}

```

# 1. Getting started


```{r}
rm(list=ls())
```


## 1.1. Basic functions  


```{r}
fsave <- function(x, file, location = "./data/processed/", ...) {
    if (!dir.exists(location))
        dir.create(location)
    datename <- substr(gsub("[:-]", "", Sys.time()), 1, 8)
    totalname <- paste(location, datename, file, sep = "")
    print(paste("SAVED: ", totalname, sep = ""))
    save(x, file = totalname)
}

fpackage.check <- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

colorize <- function(x, color) {
    sprintf("<span style='color: %s;'>%s</span>", color, x)
}

```

## 1.2. Packages

```{r}
packages = c("RsienaTwoStep", "RSiena", "doParallel", "compiler", "ggplot2")

fpackage.check(packages)
```

## 1.3. Auxiliary functions for `RSiena::SienaGOF()`

Please see: `RSiena::SienaGOF()`.  

I want to be able to have a dyadcensus/triadcensus in the GOF of Rsiena. 
Thus, these functions have been added to `RsienaTwoStep`.  

```{r}

DyadCensus.sna <- function(i, data, sims, period, groupName, varName, levls=1:3){
  unloadNamespace("igraph") # to avoid package clashes
  require(network)
  require(sna)
  x <- networkExtraction(i, data, sims, period, groupName, varName)
  if (network.edgecount(x) <= 0){x <- symmetrize(x)}
  # because else triad.census(x) will lead to an error
  tc <- sna::dyad.census(x)[levls]
  # names are transferred automatically
  tc
}

DyadCensus.sna <- cmpfun(DyadCensus.sna)


TriadCensus.sna <- function(i, data, sims, period, groupName, varName, levls=1:16){
  unloadNamespace("igraph") # to avoid package clashes
  require(network)
  require(sna)
  x <- networkExtraction(i, data, sims, period, groupName, varName)
  if (network.edgecount(x) <= 0){x <- symmetrize(x)}
  
  # because else triad.census(x) will lead to an error
  tc <- sna::triad.census(x)[levls]
  # names are transferred automatically
  tc
}

TriadCensus.sna <- cmpfun(TriadCensus.sna)


Nacf.sna <- function(i, data, sims, period, groupName, varName, cov){
  unloadNamespace("igraph") # to avoid package clashes
  require(network)
  require(sna)
  x <- networkExtraction(i, data, sims, period, groupName, varName)
  if (network.edgecount(x) <= 0){x <- symmetrize(x)}
  x <- as.sociomatrix.sna(x)
  # because else triad.census(x) will lead to an error
  snaM1 <- sna::nacf(x, cov, type = "moran", neighborhood.type = "out", demean = TRUE)[2]
  snaM1
}

Nacf.sna <- cmpfun(Nacf.sna)


network.ts <- function(i, data, sims, period, groupName, varName){
  unloadNamespace("igraph") # to avoid package clashes
  require(network)
  require(sna)
  x <- networkExtraction(i, data, sims, period, groupName, varName)
  x
}
network.ts <- cmpfun(network.ts)



```

---  

# 2. Setting up cluster

```{r, results='hide'}
#stopCluster(my.cluster) 
n.cores <- parallel::detectCores() - 1  #save one core for other work
# create the cluster
my.cluster <- parallel::makeCluster(n.cores, type = "PSOCK")
# register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)

parallel::clusterEvalQ(my.cluster, library("network"))
parallel::clusterEvalQ(my.cluster, library("RSiena"))
```


---  

# 3. Model 1: Degree and reciprocity 

## 3.1. Running `siena07()`

Make sure that in `sienaAlgorithmCreate()`: the argument `cond` is set to `FALSE` so the rate parameter is estimated and can be accessed via `summary(ans)$theta`.  
Make sure that in `siena07` the `returnDeps` argument is set to `TRUE` so the simulated networks are saved. 
If you want to be able to replicate the simulated networks by `siena07` it is best to estimate `siena07` for one period (two waves) only. 

We only include the following statistics:  
- degree  
- reciprocity  

```{r, eval=FALSE}
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata <- sienaDataCreate(mynet)
myalgorithm <- sienaAlgorithmCreate(seed=1293, cond=FALSE) #toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
ans1 <- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)
```


```{r, eval=FALSE, echo=FALSE}
fsave(ans1, file="ans1.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221220ans1.Rdata")
ans1 <- x
rm(x)
```

let's have a look
```{r}
ans1
```


## 3.2. Simulate networks via `RsienaTwoStep`  

```{r, eval=FALSE}
# Ministep
sims1 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,0,0), chain=FALSE)

# Twostep: Simultaneity 
sims2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,1,0), chain=FALSE)

# Twostep: Weak coordination 
sims3 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,1,0), dist1=2, dist2=2, chain=FALSE)

### Twostep: Strict coordination 
sims4 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,1,0), dist1=2, chain=FALSE)

### Simstep 
sims5 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,0,1), chain=FALSE)
```



```{r, echo=FALSE, eval=FALSE}
fsave(sims1, file="sims1.Rdata")
fsave(sims2, file="sims2.Rdata")
fsave(sims3, file="sims3.Rdata")
fsave(sims4, file="sims4.Rdata")
fsave(sims5, file="sims5.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221220sims1.Rdata")
sims1 <- x
rm(x)

load("./data/processed/20221220sims2.Rdata")
sims2 <- x
rm(x)

load("./data/processed/20221221sims3.Rdata")
sims3 <- x
rm(x)

load("./data/processed/20221221sims4.Rdata")
sims4 <- x
rm(x)

load("./data/processed/20230114sims5.Rdata")
sims5 <- x
rm(x)
```

## 3.3. Counting dyads

### 3.3.1. RSiena

```{r, message=FALSE}
gofi <- sienaGOF(ans1,
                 DyadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 varName = "mynet")
```

```{r}
dfrs <- as.data.frame(gofi[[1]]$Simulations)
names(dfrs) <- c("Mut", "Asym", "Null")

df <- rbind(dfrs, dfrs, dfrs)
df$x <- rep(c("mut", "asym", "null"), each=nrow(dfrs))
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "rsiena"
dfrs_siena <- df
rm(list=c("df", "dfrs"))
```


### 3.3.2. RsienaTwoStep 


```{r}
df_ts1 <- ts_dyads(sims=sims1, simtype="ministep") 
df_ts2 <- ts_dyads(sims=sims2, simtype="twostep-simultaneity")
df_ts3 <- ts_dyads(sims=sims3, simtype="twostep-weak coordination") 
df_ts4 <- ts_dyads(sims=sims4, simtype="twostep-strict coordination")
df_ts5 <- ts_dyads(sims=sims5, simtype="simstep")
```

## 3.4. Plotting dyad_census 

### 3.4.1. All three dyad types  

```{r}
df <- rbind(dfrs_siena, df_ts1, df_ts2, df_ts3, df_ts4, df_ts5)



p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

### 3.4.2. Plotting dyad census selection 

```{r}


df_sel <- df[df$x!="null", ]

dodge <- position_dodge(width = 0.5)
p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

---  

# 4. Model 2: Degree, reciprocity and 3cycle 

## 4.1. Running `siena07()`  

We only include the following statistics:  
- degree  
- reciprocity  
- cycle3  


```{r, eval=FALSE}
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata <- sienaDataCreate(mynet)
myalgorithm <- sienaAlgorithmCreate(seed=1293, cond=FALSE) #toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
myeff <- includeEffects(myeff, cycle3)
ans2 <- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)
```


```{r, eval=FALSE}
fsave(ans2, file="ans2.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221222ans2.Rdata")
ans2 <- x
rm(x)
```

let's have a look
```{r}
ans2
```


## 4.2. Simulate networks via `RsienaTwoStep`  

`r colorize("These simulations took two days to complete on a simple HP Elitebook 855 G7", "red" )`

```{r, eval=FALSE, class.source="watch-out"}
#ministep
sims1m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(1,0,0), chain=FALSE)
fsave(sims1m2, file="sims1m2.Rdata")

#simultaneity
sims2m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,1,0), chain=FALSE)
fsave(sims2m2, file="sims2m2.Rdata")

#weak coordination
sims3m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,1,0), dist1=2, dist2=2, chain=FALSE)
fsave(sims3m2, file="sims3m2.Rdata")

#strict coordination
sims4m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,1,0), dist1=2, chain=FALSE)
fsave(sims4m2, file="sims4m2.Rdata")

#simstep
sims5m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,0,1), chain=FALSE)
fsave(sims5m2, file="sims5m2.Rdata")

```


```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221222sims1m2.Rdata")
sims1m2 <- x
load("./data/processed/20221223sims2m2.Rdata")
sims2m2 <- x
load("./data/processed/20221223sims3m2.Rdata")
sims3m2 <- x
load("./data/processed/20221224sims4m2.Rdata")
sims4m2 <- x
load("./data/processed/20230114sims5m2.Rdata")
sims5m2 <- x
rm(x)
```

## 4.3. Counting dyads

### 4.3.1. RSiena

```{r, message=FALSE}
gofi <- sienaGOF(ans2,
                 DyadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 varName = "mynet")
```

```{r}
dfrs <- as.data.frame(gofi[[1]]$Simulations)
names(dfrs) <- c("Mut", "Asym", "Null")

df <- rbind(dfrs, dfrs, dfrs)
df$x <- rep(c("mut", "asym", "null"), each=nrow(dfrs))
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "rsiena"
dfrs_sienam2 <- df
rm(list=c("df", "dfrs"))
```

### 4.3.2. RsienaTwoStep 

```{r}
df_ts1m2 <- ts_dyads(sims=sims1m2, simtype="ministep") 
df_ts2m2 <- ts_dyads(sims=sims2m2, simtype="twostep-simultaneity")
df_ts3m2 <- ts_dyads(sims=sims3m2, simtype="twostep-weak coordination") 
df_ts4m2 <- ts_dyads(sims=sims4m2, simtype="twostep-strict coordination")
df_ts5m2 <- ts_dyads(sims=sims5m2, simtype="simstep")
```

## 4.4. Plotting dyad_census

### 4.4.1. All three dyad types  

```{r}
df <- rbind(dfrs_sienam2, df_ts1m2, df_ts2m2, df_ts3m2, df_ts4m2, df_ts5m2)

p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

### 4.4.2. Plotting dyad census selection 
```{r}
df_sel <- df[df$x!="null", ]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```


## 4.5. Counting triads

### 4.5.1. RSiena
```{r, message=FALSE}
nsims <- 1000
gofi <- sienaGOF(ans2,
                 TriadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 varName = "mynet")

dfrs <- as.data.frame(gofi[[1]]$Simulations)

triads <- c("003",  "012",  "102" , "021D", "021U", "021C" ,"111D", "111U" ,"030T" ,"030C", "201"  ,"120D" ,"120U" ,"120C" ,"210",  "300")

names(dfrs) <- triads


dflist <- list()
for (i in 1:length(triads)) {
  dflist[[i]] <- dfrs
}
dfrs <- do.call(rbind, dflist)
dfrs$x <- rep(triads, each=nsims)
dfrs$y <- NA

for (i in 1:length(triads)) {
  dfrs$y[dfrs$x==triads[i]] <- dfrs[,triads[i]][dfrs$x==triads[i]]
}
dfrs$type <- "rsiena"
dfrs_sienam2 <- dfrs
```


### 4.5.2 RsienaTwoStep

```{r}
df_ts1m2 <- ts_triads(sims=sims1m2, simtype="ministep") 
df_ts2m2 <- ts_triads(sims=sims2m2, simtype="twostep-simultaneity")
df_ts3m2 <- ts_triads(sims=sims3m2, simtype="twostep-weak coordination") 
df_ts4m2 <- ts_triads(sims=sims4m2, simtype="twostep-strict coordination")
df_ts5m2 <- ts_triads(sims=sims5m2, simtype="simstep")
```


## 4.6. Plotting triad census 

### 4.6.1. All triad types  

```{r}
df <- rbind(dfrs_sienam2, df_ts1m2, df_ts2m2, df_ts3m2, df_ts4m2, df_ts5m2)

p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(1)) +
  labs(x = "triad type", y = "triad count", fill="simulation type")

p
```

### 4.6.2 Plotting triad census selection I

```{r}
df_sel <- df[df$x=="030C" | df$x=="120C",]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "(cyclic) triad types", y = "triad count", fill="simulation type")

p
```

### 4.6.3 Plotting triad census selection II

```{r}
df_sel <- df[df$x=="210" | df$x=="300",]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "(cyclic) triad types", y = "triad count", fill="simulation type")

p
```

---  

# 5. Model 3: Degree, reciprocity, transitive triplets, 3cycle, smoke similarity, alcohol alter, alcohol ego, alcohol ego X alcohol alter 

## 5.1. Running `Siena07()

preparing the dataset
```{r}
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
alcohol <- s50a
smoke <- s50s
smoke <- coCovar(smoke[, 1])
alcohol <- coCovar(alcohol[, 1])
mydata <- sienaDataCreate(mynet, smoke, alcohol)
```


```{r, eval=FALSE}
myalgorithm <- sienaAlgorithmCreate(seed=1293, cond=FALSE) #toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
myeff <- includeEffects(myeff, transTrip, cycle3)
myeff <- includeEffects(myeff, egoX, altX, egoXaltX, interaction1 = "alcohol")
myeff <- includeEffects(myeff, simX, interaction1 = "smoke")
ans3 <- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)
```


```{r, eval=FALSE}
fsave(ans3, file="ans3.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20230401ans3.Rdata")
ans3 <- x
rm(x)
```

let's have a look
```{r}
ans3
```

This result is not very interesting because the covariates do not have an important impact on the selection processes. 

Let us briefly demonstrate that our RsienaTwoStep simulation leads to same network configurations



## 5.2. Simulate networks via `RsienaTwoStep`

`r colorize("These simulations took two days to complete on a simple HP Elitebook 855 G7", "red" )`

Prepare dataset for RsienaTwoStep Simulations. 

```{r, eval=FALSE}
alcohol <- s50a[,1] 
smoke <- s50s[,1] 
df <- data.frame(alcohol=alcohol, smoke=smoke)
```


```{r, eval=FALSE, class.source="watch-out"}
#ministep
sims1m3 <- ts_sims(nsims=100, parallel=TRUE, net=s501, ccovar=df, rate=summary(ans3)$theta[1], statistics=list(ts_degree, ts_recip, ts_transTrip, ts_cycle3, list(ts_simX, "smoke"), list(ts_altX, "alcohol"), list(ts_egoX, "alcohol"), list(ts_egoXaltX, "alcohol")), parameters=summary(ans3)$theta[2:9], p2step=c(1,0,0), chain=FALSE)

fsave(sims1m3, file="sims1m3.Rdata")
```



```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20230501sims1m3.Rdata")
sims1m3 <- x
rm(x)
```




## 5.3. Counting dyads

### 5.3.1. RSiena

```{r, message=FALSE}
gofi <- sienaGOF(ans3,
                 DyadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 cluster = my.cluster,
                 varName = "mynet")


```

```{r}
dfrs <- as.data.frame(gofi[[1]]$Simulations)
names(dfrs) <- c("Mut", "Asym", "Null")

df <- rbind(dfrs, dfrs, dfrs)
df$x <- rep(c("mut", "asym", "null"), each=nrow(dfrs))
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "rsiena"
dfrs_sienam3 <- df
rm(list=c("df", "dfrs"))
```

### 5.3.2. RsienaTwoStep 

```{r}
df_ts1m3 <- ts_dyads(sims=sims1m3, simtype="ministep") 
```

```{r}
df <- rbind(dfrs_sienam3, df_ts1m3)

p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```



## 5.4 Assessing segregation

### 5.4.1. Rsiena

```{r}
gofi <- sienaGOF(ans3,
                 Nacf.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 cluster = my.cluster,
                 varName = "mynet", 
                 cov=mydata$cCovars$smoke)

 
# sims <- ans3$sims
# sims[[1]]
# sna::as.sociomatrix.sna(sims[[1]])
# 
# net <- networkExtraction(i=NULL, obsData=ans3$f, sims=ans3$sims, period=1, groupName="Data1", varName="mynet")
# 
# sna::as.sociomatrix.sna(net)
# s502 == sna::as.sociomatrix.sna(net)
```

```{r}
dfrs <- as.data.frame(gofi[[1]]$Simulations)
dfrs$type <- "rsiena"
names(dfrs)[1] <- "MoranI"
```

### 5.4.2. RsienaTwoStep



```{r}
df_ts1m3 <- ts_nacf(sims=sims1m3, simtype="ministep", cov=mydata$cCovars$smoke) 
names(df_ts1m3)[1] <- "MoranI" 

```

```{r}
df <- rbind(dfrs, df_ts1m3)

p <- ggplot(df, aes(x=factor(type, levels=c("rsiena", "ministep")), y=MoranI, fill=factor(type, levels=c("rsiena", "ministep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "sim type", y = "Smoke \n MoranI", fill="sim type")

p


```
Okay, it seems RsienaTwoStep is programmed correctly. 

# 6. Model 4: Model 3 with smoke segregation

## 6.1. Simulate networks via `RsienaTwoStep`

Let us now, simulate a model with segregation. Or more precisely, that pupils have a preference for a tie with someone with similar smoking behavior. We take as starting point the estimates of `ans3`. 


```{r, eval=FALSE, class.source="watch-out"}
est <- summary(ans3)$theta[2:9]
est[5] <- .8 #count carefully :-(
est
```

Now simulate under the different twostep conditions. 

Prepare dataset for RsienaTwoStep Simulations (again). 

```{r, eval=FALSE}
alcohol <- s50a[,1] 
smoke <- s50s[,1] 
df <- data.frame(alcohol=alcohol, smoke=smoke)
```


```{r, eval=FALSE, class.source="watch-out"}
sims1m3b <- ts_sims(nsims=100, parallel=TRUE, net=s501, ccovar=df, rate=summary(ans3)$theta[1], statistics=list(ts_degree, ts_recip, ts_transTrip, ts_cycle3, list(ts_simX, "smoke"), list(ts_altX, "alcohol"), list(ts_egoX, "alcohol"), list(ts_egoXaltX, "alcohol")), parameters=est, p2step=c(1,0,0), chain=FALSE)

fsave(sims1m3b, file="sims1m3b.Rdata")

#simultaneity
sims2m3 <- ts_sims(nsims=100, parallel=TRUE, net=s501, ccovar=df, rate=summary(ans3)$theta[1], statistics=list(ts_degree, ts_recip, ts_transTrip, ts_cycle3, list(ts_simX, "smoke"), list(ts_altX, "alcohol"), list(ts_egoX, "alcohol"), list(ts_egoXaltX, "alcohol")), parameters=est, p2step=c(0,1,0), chain=FALSE)
fsave(sims2m3, file="sims2m3.Rdata")

#weak coordination
sims3m3 <- ts_sims(nsims=100, parallel=TRUE, net=s501, ccovar=df, rate=summary(ans3)$theta[1], statistics=list(ts_degree, ts_recip, ts_transTrip, ts_cycle3, list(ts_simX, "smoke"), list(ts_altX, "alcohol"), list(ts_egoX, "alcohol"), list(ts_egoXaltX, "alcohol")), parameters=est, p2step=c(0,1,0), dist1=2, dist2=2, chain=FALSE)
fsave(sims3m3, file="sims3m3.Rdata")

#strict coordination
sims4m3 <- ts_sims(nsims=100, parallel=TRUE, net=s501, ccovar=df, rate=summary(ans3)$theta[1], statistics=list(ts_degree, ts_recip, ts_transTrip, ts_cycle3, list(ts_simX, "smoke"), list(ts_altX, "alcohol"), list(ts_egoX, "alcohol"), list(ts_egoXaltX, "alcohol")), parameters=est, p2step=c(0,1,0), dist1=2, chain=FALSE)
fsave(sims4m3, file="sims4m3.Rdata")

#simstep
sims5m3 <- ts_sims(nsims=100, parallel=TRUE, net=s501, ccovar=df, rate=summary(ans3)$theta[1], statistics=list(ts_degree, ts_recip, ts_transTrip, ts_cycle3, list(ts_simX, "smoke"), list(ts_altX, "alcohol"), list(ts_egoX, "alcohol"), list(ts_egoXaltX, "alcohol")), parameters=est, p2step=c(0,0,1), chain=FALSE)
fsave(sims5m3, file="sims5m3.Rdata")

```


```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20230501sims1m3.Rdata")
sims1m3 <- x
load("./data/processed/20230507sims1m3b.Rdata")
sims1m3b <- x
load("./data/processed/20230507sims2m3.Rdata")
sims2m3 <- x
load("./data/processed/20230507sims3m3.Rdata")
sims3m3 <- x
load("./data/processed/20230507sims4m3.Rdata")
sims4m3 <- x
load("./data/processed/20230507sims5m3.Rdata")
sims5m3 <- x
rm(x)
```



## 6.2 counting dyads RsienaTwoStep 

```{r}
df_ts1m3 <- ts_dyads(sims=sims1m3, simtype="ministep-original") 
df_ts1m3b <- ts_dyads(sims=sims1m3b, simtype="ministep-with segregation") 
df_ts2m3 <- ts_dyads(sims=sims2m3, simtype="twostep-simultaneity") 
df_ts3m3 <- ts_dyads(sims=sims3m3, simtype="twostep-weak coordination") 
df_ts4m3 <- ts_dyads(sims=sims4m3, simtype= "twostep-strict coordination") 
df_ts5m3 <- ts_dyads(sims=sims5m3, simtype="simstep") 

```

### 6.2.1 Plotting all dyads

```{r}
df <- rbind(df_ts1m3, df_ts1m3b, df_ts2m3, df_ts3m3, df_ts4m3, df_ts5m3)

p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("ministep-original", "ministep-with segregation", "twostep-simultaneity","twostep-weak coordination", "twostep-strict coordination","simstep" ))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

### 6.2.1 Plotting dyads selection

```{r}
df_sel <- df[df$x=="asym" | df$x=="mut",]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("ministep-original", "ministep-with segregation", "twostep-simultaneity","twostep-weak coordination", "twostep-strict coordination","simstep" ))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

## 6.3 counting triads RsienaTwoStep 

```{r}
df_ts1m3 <- ts_triads(sims=sims1m3, simtype="ministep-original") 
df_ts1m3b <- ts_triads(sims=sims1m3b, simtype="ministep-with segregation") 
df_ts2m3 <- ts_triads(sims=sims2m3, simtype="twostep-simultaneity") 
df_ts3m3 <- ts_triads(sims=sims3m3, simtype="twostep-weak coordination") 
df_ts4m3 <- ts_triads(sims=sims4m3, simtype= "twostep-strict coordination") 
df_ts5m3 <- ts_triads(sims=sims5m3, simtype="simstep") 

```

### 6.3.1. Plotting all triad types  

```{r}
df <- rbind(df_ts1m3, df_ts1m3b, df_ts2m3, df_ts3m3, df_ts4m3, df_ts5m3)

p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("ministep-original", "ministep-with segregation", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(1)) +
  labs(x = "triad type", y = "triad count", fill="simulation type")

p
```

### 6.3.2 Plotting triad census selection I

```{r}
df_sel <- df[df$x=="030C" | df$x=="120C",]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("ministep-original", "ministep-with segregation", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "(cyclic) triad types", y = "triad count", fill="simulation type")

p
```
### 6.3.3 Plotting triad census selection II

```{r}
df_sel <- df[df$x=="210" | df$x=="300",]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("ministep-original", "ministep-with segregation", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "(cyclic) triad types", y = "triad count", fill="simulation type")

p
```


## 6.4 Assessing segregation RsienaTwoStep

```{r}
df_ts1m3 <- ts_nacf(sims=sims1m3, simtype="ministep-original", cov=mydata$cCovars$smoke) 
names(df_ts1m3)[1] <- "MoranI" 
df_ts1m3b <- ts_nacf(sims=sims1m3b, simtype="ministep-with segregation", cov=mydata$cCovars$smoke) 
names(df_ts1m3b)[1] <- "MoranI" 
df_ts2m3 <- ts_nacf(sims=sims2m3, simtype="twostep-simultaneity", cov=mydata$cCovars$smoke) 
names(df_ts2m3)[1] <- "MoranI" 
df_ts3m3 <- ts_nacf(sims=sims3m3, simtype="twostep-weak coordination", cov=mydata$cCovars$smoke) 
names(df_ts3m3)[1] <- "MoranI" 
df_ts4m3 <- ts_nacf(sims=sims4m3, simtype="twostep-strict coordination", cov=mydata$cCovars$smoke) 
names(df_ts4m3)[1] <- "MoranI" 
df_ts5m3 <- ts_nacf(sims=sims5m3, simtype="simstep", cov=mydata$cCovars$smoke) 
names(df_ts5m3)[1] <- "MoranI" 

```


```{r}
df <- rbind(df_ts1m3, df_ts1m3b, df_ts2m3, df_ts3m3, df_ts4m3, df_ts5m3)

p <- ggplot(df, aes(x=factor(type , levels=c("ministep-original", "ministep-with segregation", "twostep-simultaneity","twostep-weak coordination", "twostep-strict coordination","simstep")), y=MoranI, fill=factor(type, levels=c("ministep-original", "ministep-with segregation", "twostep-simultaneity","twostep-weak coordination", "twostep-strict coordination","simstep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "sim type", y = "Smoke \n MoranI", fill="sim type")  + 
  ylim(0, 1) + 
  theme(axis.text.x=element_blank())
        
#  labs(x = "sim type", y = "Smoke \n MoranI", fill="sim type") 
#+
#  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1))

p



```


---  


# 7. Conclusion 

- The networks simulated by `RsienaTwoStep` assuming the ministep assumption lead to identical results as the simulated networks of `RSiena`. We can hence conclude that (at least for the used statistics) `RsienaTwoStep` is programmed correctly.  
- For both model specifications, we observe that allowing for simultaneity does not really impact the observed dyads and triads in the network, although reciprocated ties seem a bit more likely. This is reassuring. A tentative conclusion would be that for relatively sparse and large networks it 'does not matter' to disregard simultaneous tie changes.  
- Both forms of coordination (weak and strict) lead to more reciprocated ties.  
- The dyad and triad census of the networks simulated assuming 'weak coordination' deviate the most from the other simulated networks. The assumption made under weak coordination is that also actors who are **`r colorize("not", "red")` connected at time t0** can initiate a coordinated tie-change. Hence, it is called weak coordination. However, these actors only evaluate twostep tie changes that lead to a connection at time t2. In other words, their choice set is reduced.  
- Under strict coordination, it is assumed that only actors **connected at time t0** can start a coordination. Hence, it is called strict coordination. These actors evaluate all twostep tie changes (also those that would be the result of two independent ministeps). In our ABM we specified that there was only strict coordination (parameter `p2step=c(0,1,0`). This will probably mean that some actors made a lot more tie-changes than others. It may be worthwhile to mix twosteps with ministeps and simsteps (i.e., `p2step=c(0.33,0.33,0.34)`).  
- Under the simstep assumption, we observe more asymmetric dyads. This, intuitively makes sense, because you cannot make a reciprocated tie all by yourself. More surprisingly is that also cyclic triads (030C and 120C) seem to occur relatively often. Whether or not this is solely the results of the abundance of asymetric dyads remains to be investigated. 



---  



