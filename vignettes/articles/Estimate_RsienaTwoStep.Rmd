---
title: "Estimation with RsienaTwoStep"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{css, echo=FALSE}
.test {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 10px;
}

.test2 {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 10px;
  background-color: white;
  color: rgb(201, 76, 76);
}


h1, .h1, h2, .h2, h3, .h3 {
  margin-top: 24px;
}





.button1 {
  background-color: grey; /* Red */ 
  border: 2px solid black;
  color: white;
  padding: 15px 32px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  /* border-radius: 12px; */
  width: 100%;
}

.button1:hover {
  box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24), 0 17px 50px 0 rgba(0,0,0,0.19);
}

.button1:active {
  border: 2px solid red;
}

pre {
  max-height: 300px;
  overflow-y: auto;
  overflow-x: auto;
  margin: 0px;
}

.watch-out {
  background-color: lightpink;
  border: 3px solid red;
  font-weight: bold;
}

.large {
  max-height: 1100px;
  overflow-y: auto;
  overflow-x: auto;
  width: 1100px;
}


body{ /* Normal  */
    font-size: 14px;
}

h1 { /* Header 1 */
    font-size: 20px;
  font-weight: bold;
}

h2 { /* Header 2 */
    font-size: 18px;
  color: DarkBlue;
}

h3 { /* Header 3 */
    font-size: 16px;
  color: DarkBlue;
}

blockquote {
  padding: 10px 20px;
  margin: 0 0 20px;
  font-size: 14px;
  border-left: 6px solid #eee;
  background-color:lightcyan
}

caption {
  font-size: 14px;
  color: black;
  font-weight: bold
}

pre.numberSource a.sourceLine {
  left: -1em;
}

```

# 1. Getting started


```{r}
rm(list=ls())
```


## 1.1. Basic functions  


```{r}
fsave <- function(x, file, location = "./data/processed/", ...) {
    if (!dir.exists(location))
        dir.create(location)
    datename <- substr(gsub("[:-]", "", Sys.time()), 1, 8)
    totalname <- paste(location, datename, file, sep = "")
    print(paste("SAVED: ", totalname, sep = ""))
    save(x, file = totalname)
}

fpackage.check <- function(packages) {
    lapply(packages, FUN = function(x) {
        if (!require(x, character.only = TRUE)) {
            install.packages(x, dependencies = TRUE)
            library(x, character.only = TRUE)
        }
    })
}

colorize <- function(x, color) {
    sprintf("<span style='color: %s;'>%s</span>", color, x)
}

```

## 1.2. Packages

```{r}
packages = c("RsienaTwoStep", "RSiena", "doParallel", "compiler", "ggplot2", "sna")

fpackage.check(packages)
```

## 1.3. Auxiliary functions for `RSiena::SienaGOF()`

Please see: `RSiena::SienaGOF()`.  

I want to be able to have a dyadcensus/triadcensus in the GOF of Rsiena. 
Thus, need to add this. 

```{r}

DyadCensus.sna <- function(i, data, sims, period, groupName, varName, levls=1:3){
  unloadNamespace("igraph") # to avoid package clashes
  require(network)
  require(sna)
  x <- networkExtraction(i, data, sims, period, groupName, varName)
  if (network.edgecount(x) <= 0){x <- symmetrize(x)}
  # because else triad.census(x) will lead to an error
  tc <- sna::dyad.census(x)[levls]
  # names are transferred automatically
  tc
}

DyadCensus.sna <- cmpfun(DyadCensus.sna)


TriadCensus.sna <- function(i, data, sims, period, groupName, varName, levls=1:16){
  unloadNamespace("igraph") # to avoid package clashes
  require(network)
  require(sna)
  x <- networkExtraction(i, data, sims, period, groupName, varName)
  if (network.edgecount(x) <= 0){x <- symmetrize(x)}
  # because else triad.census(x) will lead to an error
  tc <- sna::triad.census(x)[levls]
  # names are transferred automatically
  tc
}

TriadCensus.sna <- cmpfun(TriadCensus.sna)

```

---  

# 2. Setting up cluster

```{r}
#stopCluster(my.cluster) 
n.cores <- parallel::detectCores() - 1  #save one core for other work
# create the cluster
my.cluster <- parallel::makeCluster(n.cores, type = "PSOCK")
# register it to be used by %dopar%
doParallel::registerDoParallel(cl = my.cluster)
```

---  

# 3. Model 1: Degree and reciprocity 

## 3.1. Running `siena07()`

Make sure that in `sienaAlgorithmCreate()`: the argument `cond` is set to `FALSE` so the rate parameter is estimated and can be accessed via `summary(ans)$theta`.  
Make sure that in `siena07` the `returnDeps` argument is set to `TRUE` so the simulated networks are saved. 
If you want to be able to replicate the simulated networks by `siena07` it is best to estimate `siena07` for one period (two waves) only. 

We only include the following statistics:  
- degree  
- reciprocity  

```{r, eval=FALSE}
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata <- sienaDataCreate(mynet)
myalgorithm <- sienaAlgorithmCreate(seed=1293, cond=FALSE) #toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
ans1 <- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)
```


```{r, eval=FALSE, echo=FALSE}
fsave(ans1, file="ans1.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221220ans1.Rdata")
ans1 <- x
rm(x)
```

let's have a look
```{r}
ans1
```


## 3.2. Determine target statistics


```{r}
target_degree <- sum(s502) /  ((dim(s502)[1])^2 - dim(s502)[1])
target_recip <- (sum(s502 == 1 & t(s502)==1)) / sum(s502) #edgewise reciprocity

# library(sna)
# sna::grecip(s502, measure="dyadic.nonnull")
# dyad.census(s502)
# 35/(35 + 46)
# 
# sna::grecip(s502, measure="edgewise")
# 
# 
# gden(s502, mode="digraph", ignore.eval=FALSE)
# 
# sum(sna::degree(s502, cmode="outdegree"))
```

```{r}
simdegree <- foreach(i= 1:nrow(s502), .combine="c") %dopar%
  ts_degree(net=s502, ego=i)
simdegree <- mean(simdgree)

simrecip <- foreach(i= 1:nrow(s502), .combine="c") %dopar%
  ts_recip(net=s502, ego=i)
simrecip <- mean(simrecip)

simtrans <- foreach(i= 1:nrow(s502), .combine="c") %dopar%
  ts_transTrip(net=s502, ego=i)
simtrans <- mean(simtrans) 
```



## 3.3 Set initial values

```{r}
s_rate <- 4 
s_degree <- -1.5
s_recip <- 3
```

# 3.4 simulate 


https://stats.stackexchange.com/questions/514680/root-finding-via-robbins-monro-method-a-real-and-simple-example



```{r}
f.error <- function(x){
  #estimate model
  sims1 <- ts_sims(nsims=1, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=c(x, summary(ans1)$theta[3]), p2step=c(1,0,0), chain=FALSE)
  sim_degree <- gden(sims1[[1]]) 
  sim_recip <- grecip(sims1[[1]], measure="edgewise")
   dif1 <- (sim_degree - target_degree) #+ rnorm(n=1,mean=0,sd=0.1) 
   dif2 <- (sim_recip - target_recip) #+ rnorm(n=1,mean=0,sd=0.1) 
   dif1 + dif2
}

x = -2.2 # starting value (should not too far away from solution)
dif = Inf
ite = 0
ite2 = 1 #try to keep an constant as long as the sequence sn has not crossed the observed values
r = x
r_sub = x #for the subphase
b = 0.5
update = 0
while (dif > .0001 & ite < 100){
  ite = ite + 1 #number of iterations
  a = (1/ite2)^b
  update_old = update
  update = f.error(x)
  x = x - a*update
  r = c(r,x) # save results
  r_sub = c(r_sub,x) # save results
  if (abs(sign(update) - sign(update_old)) == 2 )  {
    ite2 = ite2 + 1 
    x <- mean(r_sub) #for new subphase take average of sequence as new starting value
    r_sub <- x 
  }
  if ((ite %% 3) == 0){
    dif = abs(x - r[ite-2])
  }
  print(x)
}
plot(1:length(r),r)

```


multivariate case

```{r}
#function to simulate model and calculate deviation scores
f.error <- function(x){
  #estimate model
  sims1 <- ts_sims(nsims=1, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=unlist(x), p2step=c(1,0,0), chain=FALSE)
  sim_degree <- gden(sims1[[1]]) 
  sim_recip <- grecip(sims1[[1]], measure="edgewise")
   dif1 <- (sim_degree - target_degree) #+ rnorm(n=1,mean=0,sd=0.1) 
   dif2 <- (sim_recip - target_recip) #+ rnorm(n=1,mean=0,sd=0.1) 
   dif1 + dif2 #total error
}

#starting values
x = list(s_degree=s_degree,s_recip=s_recip)
r = x
r_sub = x #for the subphase

#sample parameter 
pm <- sample(1:length(x), 1)

# initialize model parameters
dif = list(Inf, Inf)
ite = list(0,0)
ite2 = list(1,1) #try to keep an constant as long as the sequence sn has not crossed the observed values
b = 0.5
update = list(0,0)


while (dif[[pm]] > .0001 & ite[[pm]] < 100){
  ite[[pm]] = ite[[pm]] + 1 #number of iterations
  a = (1/ite2[[pm]])^b
  update_old[[pm]] = update[[pm]]
  update[[pm]] = f.error(x)
  x[[pm]] = x[[pm]] - a*update[[pm]]
  r[[pm]] = c(r[[pm]],x[[pm]]) # save results
  r_sub[[pm]] = c(r_sub[[pm]],x[[pm]]) # save results
  if (abs(sign(update[[pm]]) - sign(update_old[[pm]])) == 2 )  {
    ite2[[pm]] = ite2[[pm]] + 1 
    x[[pm]] <- mean(r_sub[[pm]]) #for new subphase take average of sequence as new starting value
    r_sub[[pm]] <- x[[pm]] 
  }
  if ((ite[[pm]] %% 3) == 0){
    dif[[pm]] = abs(x[[pm]] - r[[pm]][ite[[pm]]-2])
  }
  print(x[[pm]])
}
plot(1:length(r[[pm]]),r[[pm]])

```

#different loop

This one works!!! 
```{r}
f.error <- function(x){
  #estimate model
  sims1 <- ts_sims(nsims=1, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=unlist(x), p2step=c(0,1,0), chain=FALSE)
  sim_degree <- gden(sims1[[1]]) 
  sim_recip <- grecip(sims1[[1]], measure="edgewise")
   dif1 <- (sim_degree - target_degree) #+ rnorm(n=1,mean=0,sd=0.1) 
   dif2 <- (sim_recip - target_recip) #+ rnorm(n=1,mean=0,sd=0.1) 
   dif1 + dif2 #total error
}


#starting values
x = list(s_degree=s_degree,s_recip=s_recip)
r = x
r_sub = x #for the subphase

# initialize model parameters
dif = list(Inf, Inf)
ite = list(0,0)
ite2 = list(1,1) #try to keep an constant as long as the sequence sn has not crossed the observed values
b = 0.5
update = list(0,0)


while (sum(unlist(dif)) > .0001 & sum(unlist(ite)) < length(x)*100){
  #sample parameter 
  pm <- sample(1:length(x), 1)

  ite[[pm]] = ite[[pm]] + 1 #number of iterations
  a = (1/ite2[[pm]])^b
  update_old[[pm]] = update[[pm]]
  update[[pm]] = f.error(x)
  x[[pm]] = x[[pm]] - a*update[[pm]]
  r[[pm]] = c(r[[pm]],x[[pm]]) # save results
  r_sub[[pm]] = c(r_sub[[pm]],x[[pm]]) # save results
  if (abs(sign(update[[pm]]) - sign(update_old[[pm]])) == 2 )  {
    ite2[[pm]] = ite2[[pm]] + 1 
    x[[pm]] <- mean(r_sub[[pm]]) #for new subphase take average of sequence as new starting value
    r_sub[[pm]] <- x[[pm]] 
  }
  if ((ite[[pm]] %% 3) == 0){
    dif[[pm]] = abs(x[[pm]] - r[[pm]][ite[[pm]]-2])
  }
  print(x[[pm]])
}
plot(1:length(r[[pm]]),r[[pm]])
```




use different parameters b
```{r}
f.error <- function(x){
  #estimate model
  sims1 <- ts_sims(nsims=1, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=c(x, summary(ans1)$theta[3]), p2step=c(1,0,0), chain=FALSE)
  sim_degree <- sum(sims1[[1]]) / (dim(s502)[1])^2
   (sim_degree - target_degree) #+ rnorm(n=1,mean=0,sd=0.1) 
}

f.rm <- function(y, lambda) y - lambda * f.error(y)

start = -1

b = 0.3
iterations <- seq_len(1e2) 
lambda <- iterations^(-b)
results <- Reduce(f.rm, lambda, start, accumulate=TRUE)

start <- results[length(results)]
start <- -2.03

b = 0.6
iterations <- seq_len(1e2) 
lambda <- iterations^(-b)
results <- Reduce(f.rm, lambda, start, accumulate=TRUE)

start <- results[length(results)]

b = 0.8
iterations <- seq_len(1e2) 
lambda <- iterations^(-b)
results <- Reduce(f.rm, lambda, start, accumulate=TRUE)


```


try with both reciprocity and degree

```{r}
f.error <- function(x){
  #estimate model
  sims1 <- ts_sims(nsims=1, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=c(x, summary(ans1)$theta[3]), p2step=c(1,0,0), chain=FALSE)
  sim_degree <- gden(sims1[[1]]) 
  sim_recip <- grecip(sims1[[1]], measure="edgewise")
   dif1 <- (sim_degree - target_degree) #+ rnorm(n=1,mean=0,sd=0.1) 
   dif2 <- (sim_recip - target_recip) #+ rnorm(n=1,mean=0,sd=0.1) 
   dif1 + dif2
   
}

f.rm <- function(y, lambda) y - lambda * f.error(y)

start = -1

b = 0.3
iterations <- seq_len(1e2) 
lambda <- iterations^(-b)
results <- Reduce(f.rm, lambda, start, accumulate=TRUE)

start <- results[length(results)]

b = 0.6
iterations <- seq_len(1e2) 
lambda <- iterations^(-b)
results <- Reduce(f.rm, lambda, start, accumulate=TRUE)

start <- results[length(results)]

b = 0.8
iterations <- seq_len(1e2) 
lambda <- iterations^(-b)
results <- Reduce(f.rm, lambda, start, accumulate=TRUE)

start <- results[length(results)]
start

```





```{r}
iterations <- seq_len(1e2)    # Specify the number of iterations
b = 0.5 
lambda <- iterations^(-b)

set.seed(17)
iterations <- seq_len(1e4)    # Specify the number of iterations
lambda <- iterations^(-b)
#burn.period <- 1e2            # Skip these initial results when scaling the plots
replicates <- 2              # Specify how many starting values to use
bs <- c(0.5, 0.6, .7, .8)      # Specify which `b` values to explore

start = x = -2.2 # starting value (should not too far away from solution)
as <- sort(rt(replicates, 3, x)) # use different starting values


f.error <- function(x){
  #estimate model
  sims1 <- ts_sims(nsims=1, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=c(x, summary(ans1)$theta[3]), p2step=c(1,0,0), chain=FALSE)
  sim_degree <- sum(sims1[[1]]) / (dim(s502)[1])^2
   (sim_degree - target_degree) #+ rnorm(n=1,mean=0,sd=0.1) 
}

f.rm <- function(y, lambda) y - lambda * f.error(y)

lambda

Reduce(f.rm, lambda, start, accumulate=TRUE)

for (b in bs) {
  #
  # Find the solutions for each starting value `start`.
  #
  lambda <- iterations^(-b)
  solutions <- sapply(as, function(start) {
    Reduce(f.rm, lambda, start, accumulate=TRUE)
  })
}

solutions

           
```


```{r, eval=FALSE}
# Ministep
sims1 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,0,0), chain=FALSE)

# Twostep: Simultaneity 
sims2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,1,0), chain=FALSE)

# Twostep: Weak coordination 
sims3 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,1,0), dist1=2, dist2=2, chain=FALSE)

### Twostep: Strict coordination 
sims4 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,1,0), dist1=2, chain=FALSE)

### Simstep 
sims5 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans1)$theta[1], statistics=list(ts_degree, ts_recip), parameters=summary(ans1)$theta[2:3], p2step=c(0,0,1), chain=FALSE)
```



```{r, echo=FALSE, eval=FALSE}
fsave(sims1, file="sims1.Rdata")
fsave(sims2, file="sims2.Rdata")
fsave(sims3, file="sims3.Rdata")
fsave(sims4, file="sims4.Rdata")
fsave(sims5, file="sims5.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221220sims1.Rdata")
sims1 <- x
rm(x)

load("./data/processed/20221220sims2.Rdata")
sims2 <- x
rm(x)

load("./data/processed/20221221sims3.Rdata")
sims3 <- x
rm(x)

load("./data/processed/20221221sims4.Rdata")
sims4 <- x
rm(x)

load("./data/processed/20230114sims5.Rdata")
sims5 <- x
rm(x)
```

## 3.3. Counting dyads

### 3.3.1. RSiena

```{r}
gofi <- sienaGOF(ans1,
                 DyadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 varName = "mynet")
```

```{r}
dfrs <- as.data.frame(gofi[[1]]$Simulations)
names(dfrs) <- c("Mut", "Asym", "Null")

df <- rbind(dfrs, dfrs, dfrs)
df$x <- rep(c("mut", "asym", "null"), each=nrow(dfrs))
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "rsiena"
dfrs_siena <- df
rm(list=c("df", "dfrs"))
```


### 3.3.2. RsienaTwoStep 


```{r}
df_ts1 <- ts_dyads(sims=sims1, simtype="ministep") 
df_ts2 <- ts_dyads(sims=sims2, simtype="twostep-simultaneity")
df_ts3 <- ts_dyads(sims=sims3, simtype="twostep-weak coordination") 
df_ts4 <- ts_dyads(sims=sims4, simtype="twostep-strict coordination")
df_ts5 <- ts_dyads(sims=sims5, simtype="simstep")
```

## 3.4. Plotting dyad_census 

### 3.4.1. All three dyad types  

```{r}
df <- rbind(dfrs_siena, df_ts1, df_ts2, df_ts3, df_ts4, df_ts5)



p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

### 3.4.2. Plotting dyad census selection 

```{r}


df_sel <- df[df$x!="null", ]

dodge <- position_dodge(width = 0.5)
p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

---  

# 4. Model 2: Degree, reciprocity and 3cycle 

## 4.1. Running `siena07()`  

We only include the following statistics:  
- degree  
- reciprocity  
- cycle3  


```{r, eval=FALSE}
mynet <- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata <- sienaDataCreate(mynet)
myalgorithm <- sienaAlgorithmCreate(seed=1293, cond=FALSE) #toggle set conditional to retrieve the rate parameter in theta!
myeff <- getEffects(mydata)
myeff <- includeEffects(myeff, cycle3)
ans2 <- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps = TRUE)
```


```{r, eval=FALSE}
fsave(ans2, file="ans2.Rdata")
```

```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221222ans2.Rdata")
ans2 <- x
rm(x)
```

let's have a look
```{r}
ans2
```


## 4.2. Simulate networks via `RsienaTwoStep`  

`r colorize("These simulations took two days to complete on a simple HP Elitebook 855 G7", "red" )`

```{r, eval=FALSE, class.source="watch-out"}
#ministep
sims1m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(1,0,0), chain=FALSE)
fsave(sims1m2, file="sims1m2.Rdata")

#simultaneity
sims2m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,1,0), chain=FALSE)
fsave(sims2m2, file="sims2m2.Rdata")

#weak coordination
sims3m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,1,0), dist1=2, dist2=2, chain=FALSE)
fsave(sims3m2, file="sims3m2.Rdata")

#strict coordination
sims4m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,1,0), dist1=2, chain=FALSE)
fsave(sims4m2, file="sims4m2.Rdata")

#simstep
sims5m2 <- ts_sims(nsims=1000, parallel=TRUE, net=s501, rate=summary(ans2)$theta[1], statistics=list(ts_degree, ts_recip, ts_cycle3), parameters=summary(ans2)$theta[2:4], p2step=c(0,0,1), chain=FALSE)
fsave(sims5m2, file="sims5m2.Rdata")

```


```{r, eval=TRUE, echo=FALSE}
load("./data/processed/20221222sims1m2.Rdata")
sims1m2 <- x
load("./data/processed/20221223sims2m2.Rdata")
sims2m2 <- x
load("./data/processed/20221223sims3m2.Rdata")
sims3m2 <- x
load("./data/processed/20221224sims4m2.Rdata")
sims4m2 <- x
load("./data/processed/20230114sims5m2.Rdata")
sims5m2 <- x
rm(x)
```

## 4.3. Counting dyads

### 4.3.1. RSiena

```{r}
gofi <- sienaGOF(ans2,
                 DyadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 varName = "mynet")
```

```{r}
dfrs <- as.data.frame(gofi[[1]]$Simulations)
names(dfrs) <- c("Mut", "Asym", "Null")

df <- rbind(dfrs, dfrs, dfrs)
df$x <- rep(c("mut", "asym", "null"), each=nrow(dfrs))
df$y <- NA
df$y[df$x=="mut"] <- df$Mut[df$x=="mut"]
df$y[df$x=="asym"] <- df$Asym[df$x=="asym"]
df$y[df$x=="null"] <- df$Null[df$x=="null"]
df$type <- "rsiena"
dfrs_sienam2 <- df
rm(list=c("df", "dfrs"))
```

### 4.3.2. RsienaTwoStep 

```{r}
df_ts1m2 <- ts_dyads(sims=sims1m2, simtype="ministep") 
df_ts2m2 <- ts_dyads(sims=sims2m2, simtype="twostep-simultaneity")
df_ts3m2 <- ts_dyads(sims=sims3m2, simtype="twostep-weak coordination") 
df_ts4m2 <- ts_dyads(sims=sims4m2, simtype="twostep-strict coordination")
df_ts5m2 <- ts_dyads(sims=sims5m2, simtype="simstep")
```

## 4.4. Plotting dyad_census

### 4.4.1. All three dyad types  

```{r}
df <- rbind(dfrs_sienam2, df_ts1m2, df_ts2m2, df_ts3m2, df_ts4m2, df_ts5m2)

p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```

### 4.4.2. Plotting dyad census selection 
```{r}
df_sel <- df[df$x!="null", ]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep"))) ) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "dyad type", y = "dyad count", fill="simulation type")

p

```


## 4.5. Counting triads

### 4.5.1. RSiena
```{r}
nsims <- 1000
gofi <- sienaGOF(ans2,
                 TriadCensus.sna, 
                 verbose = TRUE,
                 join = TRUE, 
                 varName = "mynet")

dfrs <- as.data.frame(gofi[[1]]$Simulations)

triads <- c("003",  "012",  "102" , "021D", "021U", "021C" ,"111D", "111U" ,"030T" ,"030C", "201"  ,"120D" ,"120U" ,"120C" ,"210",  "300")

names(dfrs) <- triads


dflist <- list()
for (i in 1:length(triads)) {
  dflist[[i]] <- dfrs
}
dfrs <- do.call(rbind, dflist)
dfrs$x <- rep(triads, each=nsims)
dfrs$y <- NA

for (i in 1:length(triads)) {
  dfrs$y[dfrs$x==triads[i]] <- dfrs[,triads[i]][dfrs$x==triads[i]]
}
dfrs$type <- "rsiena"
dfrs_sienam2 <- dfrs
```


### 4.5.2 RsienaTwoStep

```{r}
df_ts1m2 <- ts_triads(sims=sims1m2, simtype="ministep") 
df_ts2m2 <- ts_triads(sims=sims2m2, simtype="twostep-simultaneity")
df_ts3m2 <- ts_triads(sims=sims3m2, simtype="twostep-weak coordination") 
df_ts4m2 <- ts_triads(sims=sims4m2, simtype="twostep-strict coordination")
df_ts5m2 <- ts_triads(sims=sims5m2, simtype="simstep")
```


## 4.6. Plotting triad census 

### 4.6.1. All triad types  

```{r}
df <- rbind(dfrs_sienam2, df_ts1m2, df_ts2m2, df_ts3m2, df_ts4m2, df_ts5m2)

p <- ggplot(df, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(1)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(1)) +
  labs(x = "triad type", y = "triad count", fill="simulation type")

p
```

### 4.6.2 Plotting triad census selection I

```{r}
df_sel <- df[df$x=="030C" | df$x=="120C",]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "(cyclic) triad types", y = "triad count", fill="simulation type")

p
```

### 4.6.3 Plotting triad census selection II

```{r}
df_sel <- df[df$x=="210" | df$x=="300",]

p <- ggplot(df_sel, aes(x=x, y=y, fill=factor(type, levels=c("rsiena", "ministep", "twostep-simultaneity", "twostep-weak coordination", "twostep-strict coordination", "simstep")))) + 
  geom_violin(position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "errorbar",
               fun.max = function(x) mean(x) + sd(x),
               fun.min = function(x) mean(x) - sd(x),
               width=.1,
               color="red", position=position_dodge(.8)) + 
  stat_summary(fun = mean,
               geom = "point",
               color="red", position=position_dodge(.8)) +
  labs(x = "(cyclic) triad types", y = "triad count", fill="simulation type")

p
```

---  

# 5. Conclusion 

- The networks simulated by `RsienaTwoStep` assuming the ministep assumption lead to identical results as the simulated networks of `RSiena`. We can hence conclude that (at least for the used statistics) `RsienaTwoStep` is programmed correctly.  
- For both model specifications, we observe that allowing for simultaneity does not really impact the observed dyads and triads in the network, although reciprocated ties seem a bit more likely. This is reassuring. A tentative conclusion would be that for relatively sparse and large networks it 'does not matter' to disregard simultaneous tie changes.  
- Both forms of coordination (weak and strict) lead to more reciprocated ties.  
- The dyad and triad census of the networks simulated assuming 'weak coordination' deviate the most from the other simulated networks. The assumption made under weak coordination is that also actors who are **`r colorize("not", "red")` connected at time t0** can initiate a coordinated tie-change. Hence, it is called weak coordination. However, these actors only evaluate twostep tie changes that lead to a connection at time t2. In other words, their choice set is reduced.  
- Under strict coordination, it is assumed that only actors **connected at time t0** can start a coordination. Hence, it is called strict coordination. These actors evaluate all twostep tie changes (also those that would be the result of two independent ministeps). In our ABM we specified that there was only strict coordination (parameter `p2step=c(0,1,0`). This will probably mean that some actors made a lot more tie-changes than others. It may be worthwhile to mix twosteps with ministeps and simsteps (i.e., `p2step=c(0.33,0.33,0.34)`).  
- Under the simstep assumption, we observe more asymmetric dyads. This, intuitively makes sense, because you cannot make a reciprocated tie all by yourself. More surprisingly is that also cyclic triads (030C and 120C) seem to occur relatively often. Whether or not this is solely the results of the abundance of asymetric dyads remains to be investigated. 



---  



